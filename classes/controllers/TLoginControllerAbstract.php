<?php


namespace dr\classes\controllers;

use dr\classes\models\TUsersAbstract;
use dr\classes\models\TUsersFloodDetectAbstract;
use dr\classes\models\TUsersSessionsAbstract;
use dr\classes\models\TModel;

use dr\classes\dom\FormGenerator;    
use dr\classes\dom\tag\form\Form;
use dr\classes\dom\tag\form\InputSubmit;
use dr\classes\dom\tag\form\InputButton;
use dr\classes\dom\tag\form\InputPassword;
use dr\classes\dom\tag\form\InputCheckbox;
use dr\classes\dom\tag\form\InputEmail;
use dr\classes\dom\tag\form\InputHidden;
use dr\classes\dom\tag\form\Select;
use dr\classes\dom\tag\form\InputText;
use dr\classes\dom\tag\Li;
use dr\classes\dom\tag\Text;
use dr\classes\dom\tag\form\Option;
use dr\classes\dom\validator\Characterwhitelist;
use dr\classes\dom\validator\Emailaddress;
use dr\classes\dom\validator\Maximumlength;
use dr\classes\dom\validator\Required;
use dr\classes\dom\validator\StrongPassword;
use dr\classes\dom\validator\Repeatfieldvalue;
use dr\classes\locale\TCountrySettings;
use dr\classes\types\TDateTime;
use dr\classes\mail\TMailSend;
use dr\classes\models\TSysCMSUsers;

include_once(GLOBAL_PATH_LOCAL_LIBRARIES.DIRECTORY_SEPARATOR.'lib_misc.php');
include_once(GLOBAL_PATH_LOCAL_LIBRARIES.DIRECTORY_SEPARATOR.'lib_math.php');



/**
 * Description of TLoginControllerAbstract
 * login actions to do with authentication of a user in a system like CMS, webshop etc.
 * 
 * this class is accompanied with TUsersAbstract, TUserSessionsAbstract and TUsersFloodDetectAbstract class.
 * if it fails, the user is sent back to the script where the login happened,
 * if it is successful the user is send to a url you can define in the constructor
 * 
 * the goal of this class is:
 * - to keep it lightweight due to OOP performance issues in PHP, so no parent class (and if: it needs to be as flat as possible when it comes to parent classes depth)
 * - by inheriting this class you have ALL login features you might possibly need (flood detection, loginsessions, password recovery, creating account etc...) with MINIMAL EFFORT
 * 
 * to get messages from the controller use: 
 * ->getMessageNormal()
 * ->getMessageError()
 * don't use the _GET parameters for messages because not every message (like logout) is sent via _GET
 * 
 * You can have multiple instances of this class running on 1 website, as long as the generated id via getControllerID() is different.
 * ($_SESSION is used on every instance, but getControllerID() makes it unique so they won't interfere)
 * 
 * 
 * 
 ************************************
 * FORM TOKEN
 ************************************
 * When you load a form with this class, it has a formtoken.
 * This token is generated by this class and stored in the session.
 * When the user submits the form, the formtoken is checked against the token in the session.
 * This way you are not able to login with a form outside the current website (because you don't have the formtoken).
 * Which means that you have to go through all the flood detection methods this class provides.
 * 
 ************************************
 * LOGIN TOKEN
 ************************************
 * Formtokens and logintokens are 2 separate things.
 * Logintokens are tokens stored in session or cookie that authenticate a user.
 * A logintoken is basically a temporary password for the session.
 * By using a logintoken you don't have to store a password in a session or cookie (which is much safer) 
 * 
 ************************************
 * EMAIL TOKEN
 ************************************
 * Email tokens are tokens embedded in an email to verify a user, on create account and password resets.
 * it is basically a login token in functionality, except that is only works for create account and password resets 
 * Email tokens are stored database as a field in the users table (TUserAbstract)
 * Both password resets and account creation use the same tokenfields in database and token functions (only their purpose is different)
 * 
 ************************************
 * FLOOD DETECTION
 ************************************
 * This class uses flood detection for failed login attempts, successfull login attempts, password change attempts, account create attempts
 * based on ip, browser fingerprint, username (if available) and sessions.
 * 
 * Also flood detection (failed login attempts, successfull login attempts, password change attempts, account create attempts) 
 * is done via sessions (alongside database).
 * In order to bypass this flood detection as attacker, you have generate a new sessionid on every page load (or disable cookies),
 * but then you also get rid of the formtoken, which you need for logging in :)
 * 
 ***********************************
 * Fingerprints
 ************************************
 * browser fingerprinting is used in 2 areas:
 * -user sessions (includes ip address)
 * -flood control (no ip address)
 * 
 * an ip address included makes a fingerprint more unique, however when it comes to flood control, 
 * you can try to flood a site by constantly changing your ip address.
 * So we don't want an ip address in the flood control.
 * As an extra security bonus, the fingerprints of the usersession dbtable and floodcontrol dbtabel 
 * are different
 * 
 ************************************
 * HOW TO USE THIS CLASS:
 ************************************
 * -inherit this class and implement the abstract functions
 * -on the page of the loginform:
    $objLoginController = new TCMSLoginController();    
    $objLoginController->populateFormLogin();    
    $objLoginController->handleLogin();
 * -in the template of the loginform:
     echo $objLoginController->getFormLogin()->generate()->renderHTMLNode();
 * -include this class on every page that you want to check for authentication and call:
    $objLoginController->handleAuthentication();  
 * 
 *************************************
 * IF LOGIN DOESN'T WORK, CHECK THE FOLLOWING:
 *************************************
 * -https: if GLOBAL_ISHTTPS is wrong, cookies won't work. if the loginform is http and the rest https, this won't work
 * -if cookies are disabled in the browser
 * -This class won't work: if the user would renew their phpsessionid with every page reload
 * -do you have multiple instances of this controller on 1 website that generate the same id via $this->getControllerID() (every instance must have its own ID, otherwise they will interfere with each other)
 * 
 * 
 * @author drenirie
 * 
 * 16 jan 2020: TLoginControllerAbstract() session id is refreshed on login and logout to prevent cookie stealing
 * 16 jan 2020: TLoginControllerAbstract() flood detection werkt nu
 * 16 jan 2020: TLoginControllerAbstract() failed login attempts worden verwijderd bij succesvol login
 * 17 jan 2020: TLoginControllerAbstract() getUseKeepLoggedIn() toegevoegd en bijgehorende functionaliteit toegevoegd
 * 3 nov 2020: TLoginControllerAbstract(): authenticate() checks first on session, then on cookie. this is much safer
 * 4 nov 2020: TLoginControllerAbstract(): getIsLoggedIn() function added
 * 11 dec 2020: TLoginControllerAbstract(): some renames getForm() -> getFormLogin, objForm -> objFormLogin
 * 11 dec 2020: TLoginControllerAbstract(): added form for password recovery
 * 21,22,23 juni 2021: TLoginControllerAbstract(): a lot has happened. the security increased soooo much
 * 11 sept 2021: TLoginControllerAbstract(): detect flood on emailaddress fingerprint create account
 * 11 sept 2021: TLoginControllerAbstract(): create account with encrypted and fingerprinted emailaddress (including: check duplicate email addressses)
  * 11 sept 2021: TLoginControllerAbstract(): detect flood on emailaddress fingerprint password reset
  * 2 okt 2021: TLoginControllerAbstract(): extra preventTimingAttacks() added when formchecks fail
  * 21 jan 2023: TLoginControllerAbstract(): uses recaptchav3 features of FormGenerator, instead of implementing it ourselves
 * 
 */
abstract class TLoginControllerAbstract
{
    const SESSIONCOOKIEARRAYKEY_LOGINTOKENID                    = 'sT1'; //numeric db-session-id, plaintext in db (it's randomid, not the real record id)
    const SESSIONCOOKIEARRAYKEY_LOGINTOKENENCRYPTED             = 'sT3'; //plaintext in db, plaintext in session/cookie
    const SESSIONARRAYKEY_FLOODDETECT_FAILEDLOGINATTEMPTS       = 'sFlDeFLA'; //stores array of integer timestamps for flood detection on failed login attempts
    const SESSIONARRAYKEY_FLOODDETECT_SUCCESSFULLOGINATTEMPTS   = 'sFlDeSLA'; //stores array of integer timestamps for flood detection on succeeded login attempts
    const SESSIONARRAYKEY_FLOODDETECT_PASSWORDRESETATTEMPTS     = 'sFlDePRA'; //stores array of integer timestamps for flood detection on password reset attempts
    const SESSIONARRAYKEY_FLOODDETECT_CREATEACCOUNTATTEMPTS     = 'sFlDeCAT'; //stores array of integer timestamps for flood detection on create-account attempts
    const SESSIONARRAYKEY_FORMTOKEN                             = 'sFoTo'; //stores array of formtokens given out in the past
    
    const BOGUSLOGINTOKENSGENERATED = 5;//generate 15 bogus login tokens (including the 3 existing ones (token1, token2, dbsessionrandomid) ); 20 tokens or so is too much it will generate a 502 error 
    const LOGINTOKENPREFIX = 'sT';//prefix for the login token

    const GETARRAYKEYLOGOUT = 'logout';//if $_GET[GETARRAYKEYLOGOUT] ==  GETARRAYKEYLOGOUTVALUE then log out and render all authentications useless
    const GETARRAYKEYLOGOUTVALUE = '1';
    const GETARRAYKEYCONTROLLERID = 'cuid';//if we need to supply the Controller id for this class, such as logout
    const GETARRAYKEYMESSAGENORMAL = 'mn'; //if we need to use messages via url
    const GETARRAYKEYMESSAGEERROR = 'me'; //if we need to use error messages via url
    const GETARRAYKEY_USER_RANDOMID = 'id1'; //user randomid, used for password recovery and account creation
    const GETARRAYKEY_USER_EMAILTOKEN = 'id2'; //user emailtoken, used for password recovery and account creation
    const GETARRAYKEY_USER_USERNAME = 'id3'; //hashed username, used for password recovery and account creation
        
    const FLOODDETECT_COUNTUNIT_PERDAY = 1;//1=each day, 14=every 2 weeks, 30=each month
    const FLOODDETECT_COUNTUNIT_PERMONTH = 30;//1=each day, 14=every 2 weeks, 30=each month

    // const RECAPTCHA_SITEVERIFYURL = 'https://www.google.com/recaptcha/api/siteverify';

    const CHARSALLOWED_FORMFIELDS = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789:;_+=.,!@#$%^&*(){}?'; //all fields: username, password, email etc. First line of defense agains attackers -- these need to be consistent with the StrongPassword class, otherwise they could mutually exclude each other


    //ak=array key
    private $sAKSCATokenID = '';// the same as SESSIONCOOKIEARRAYKEY_LOGINTOKENID but with controller-id added    
    private $sAKSCAToken = '';// the same as SESSIONCOOKIEARRAYKEY_LOGINTOKEN2ENCRYPTED but with controller-id added
    private $sAKFloodDetectionFailedLoginAttempts = '';// the same as SESSIONARRAYKEY_FLOODDETECT_FAILEDLOGINATTEMPTS but with controller-id added
    private $sAKFloodDetectionSuccessfulLoginAttempts = '';// the same as SESSIONARRAYKEY_FLOODDETECT_SUCCESSFULLOGINATTEMPTS but with controller-id added
    private $sAKFloodDetectionPasswordResetAttempts = '';// the same as SESSIONARRAYKEY_FLOODDETECT_PASSWORDRESETATTEMPTS but with controller-id added
    private $sAKFloodDetectionCreateAccountAttempts = '';// the same as SESSIONARRAYKEY_FLOODDETECT_CREATEACCOUNTATTEMPTS but with controller-id added
    private $sAKFormToken = '';// the same as SESSIONARRAYKEY_FLOODDETECT_CREATEACCOUNTATTEMPTS but with controller-id added
    
    private $sControllerID = null;  
    private $objUsers = null;  
    private $objUsersFloodDetectModel = null;  
    private $objUsersSessions = null;  
    private $objLanguage = null;//language object of the user
    private $sURLLoginForm = '';
    private $sURLLoginSuccess = '';    
    private $sURLPasswordRecoverEnterEmail = '';    
    private $sURLPasswordRecoverEnterPassword = '';    
    private $sMailbotFromEmailAddress = 'noreply@example.com';
    private $sMailbotFromName = 'System';
    private $sMessageNormal = '';//messages like: "logged out successfully"
    private $sMessageError = '';//messages like: "login failed"
    private $bUseKeepLoggedIn = false;//use the keep-me-logged-in system
    
    private $objFormLogin = null;//dr\classes\dom\FormGenerator
    private $objFormPassworRecover = null;//dr\classes\dom\FormGenerator
    protected $objFormCreateAccount = null;//dr\classes\dom\FormGenerator --> protected because we can have some dedicated stuff with extra fields like language in the child class

    protected $objSubmit = null;//dr\classes\dom\tag\form\InputSubmit
    protected $objEdtUsername = null;//dr\classes\dom\tag\form\InputText
    protected $objEdtPassword = null;//dr\classes\dom\tag\form\InputPassword
    protected $objEdtPasswordConfirm = null;//dr\classes\dom\tag\form\InputPassword
    protected $objEdtEmailAddress = null;//dr\classes\dom\tag\form\InputText
    protected $objChkKeepMeLoggedIn = null;//dr\classes\dom\tag\form\InputCheck
    protected $objHdEmailToken = null;//dr\classes\dom\tag\form\InputHidden --> hidden field for password recover
    protected $objHdUserRandomID = null;//dr\classes\dom\tag\form\InputHidden --> hidden field for password recover
    protected $objHdUsernameHashed = null;//dr\classes\dom\tag\form\InputHidden --> hidden field for password recover
    protected $objHDFormToken = null;//dr\classes\dom\tag\form\InputHidden --> hidden field for a form token. this token is given out by this class (stored in session) and needs to be present on submitting a form. This way we know for sure that THIS form is used and NOT one from an external site

    private $bIsLoggedIn = false; //registers if the controller is logged in or not. this DOES NOT include the user permissions!!!!!!
    private $bShowPasswordRecoverLink = true; //for the template: determines if a link is shown for password recovery. We wan't to show the link when too many failed login attempts, but not show when too many overall attempts
    private $bShowCreateAccountLink = true; //for the template: determines if a link is shown for creating an account. We wan't to show the link when too many failed login attempts OR when it's disabled, but not show when too many overall attempts

    private $objGoogleClient = null;//Google_Client: for sign-in-with-google


    /**
     * 
     * this login system needs to be unique, otherwise the CMS and the Webshop for example
     * use the same variables for users, which will conflict with each other
     * name the login for the cms 'cms' and webshop 'webshop' for example, 
     * but if you have 2 webshops use 2 different ids
     * 
     */
    public function __construct()
    {   
        $this->bIsLoggedIn = false;
        $this->bShowPasswordRecoverLink = true;
        $this->bShowCreateAccountLink = $this->getCanAnyoneCreateAccount();
        $this->sURLLoginForm = $this->getURLLoginForm();
        $this->sURLLoginSuccess = $this->getURLLoginSuccess();
        $this->sURLLoginSuccessUserChangePassword = $this->getURLLoginSuccessUserChangePassword();
        $this->sURLPasswordRecoverEnterEmail = $this->getURLPasswordRecoverEnterEmail();
        $this->sURLPasswordRecoverEnterPassword = $this->getURLPasswordRecoverEnterPassword();

        $this->sMailbotFromEmailAddress = $this->getMailbotFromEmailAddress();
        $this->sMailbotFromName = $this->getMailbotFromName();

        $this->objUsers = $this->getNewUsers();
        $this->objUsersFloodDetectModel = $this->getNewUsersFloodDetectModel();
        $this->objUsersSessions = $this->getNewUsersSessions();
        $this->objLanguage = $this->getNewLanguage();
        $this->sControllerID = $this->getControllerID();
        
        $this->sAKSCATokenID = $this->getTokenIDSessionCookieKey();
        $this->sAKSCAToken = $this->getTokenSessionCookieKey();
        $this->sAKFloodDetectionFailedLoginAttempts = $this->getFloodDetectionFailedLoginAttemptsKey();
        $this->sAKFloodDetectionSuccessfulLoginAttempts = $this->getFloodDetectionSuccessfulLoginAttemptsKey();
        $this->sAKFloodDetectionPasswordResetAttempts = $this->getFloodDetectionPasswordResetAttemptsKey();
        $this->sAKFloodDetectionCreateAccountAttempts = $this->getFloodDetectionCreateAccountAttemptsKey();
        $this->sAKFormToken = $this->getFormTokenKey();
        
        $this->bUseKeepLoggedIn = $this->getUseKeepLoggedIn();
                
        if (isset($_GET[TLoginControllerAbstract::GETARRAYKEYMESSAGENORMAL]))
            $this->sMessageNormal = $_GET[TLoginControllerAbstract::GETARRAYKEYMESSAGENORMAL];
        if (isset($_GET[TLoginControllerAbstract::GETARRAYKEYMESSAGEERROR]))
            $this->sMessageError = $_GET[TLoginControllerAbstract::GETARRAYKEYMESSAGEERROR];     

        //sign-in-with-google
        if ($this->getUseSigninWithGoogle())
        {

            require_once GLOBAL_PATH_LOCAL_VENDOR.DIRECTORY_SEPARATOR.'googleapi/vendor/autoload.php';// we can't do it earlier, because we don't know yet if we need to use the google login (only TCMSLoginController knows, because its a CMS setting)

            $this->objGoogleClient = new \Google_Client();    

            $this->objGoogleClient->setClientId(GLOBAL_GOOGLEAPI_CLIENTID);
            $this->objGoogleClient->setClientSecret(GLOBAL_GOOGLEAPI_CLIENTSECRET);
            $this->objGoogleClient->setApplicationName($this->getApplicationName());
                  
            $this->objGoogleClient->setRedirectUri(removeVariableFromURL(getURLThisScript())); //this needs to match very literally in google cloud developer console (including parameters)
            // $this->objGoogleClient->setRedirectUri('https://www.socialvideoplaza.com/testyoutubeapi/');//echt letterlijk overnemen van google cloud developer console
            // $this->objGoogleClient->setRedirectUri('https://www.bedrijfsuitje.events/admindr/');//echt letterlijk overnemen van google cloud developer console
            
            //scopes (what does the application have access to?)
            // $this->objGoogleClient->addScope("email");
            // $this->objGoogleClient->addScope("profile");
            // $this->objGoogleClient->addScope("https://www.googleapis.com/auth/youtube");         
            if (GLOBAL_GOOGLEAPI_SCOPES)
            {
                if (is_array(GLOBAL_GOOGLEAPI_SCOPES))
                {
                    foreach(GLOBAL_GOOGLEAPI_SCOPES as $sGoogleApiScope)
                        $this->objGoogleClient->addScope($sGoogleApiScope);
                }
                else
                    logError(__CLASS__.': '.__FUNCTION__.': '.__LINE__, 'GLOBAL_GOOGLEAPI_SCOPES is not an array');
            }
        }
    }
    
    public function getIsLoggedIn()
    {
        return $this->bIsLoggedIn;
    }

    protected function setIsLoggedIn($bLoggedIn)
    {
        $this->bIsLoggedIn = $bLoggedIn;
    }


    /**
     * used for communicating with the template wether to show the link or not.
     * 
     * 
     * @return void
     */    
    public function getShowPasswordRecoverLink()
    {
        return $this->bShowPasswordRecoverLink;
    }

    /**
     * used for communicating with the template wether to show the link or not.
     * 
     * 
     * @return bool
     */      
    protected function setShowPasswordRecoverLink($bShow)
    {
        $this->bShowPasswordRecoverLink = $bShow;
    }

    /**
     * used for communicating with the template wether to show the link or not.
     * 
     * if getCanAnyoneCreateAccount() == false, this function will ALLWAYS return false
     * 
     * @return void
     */
    public function getShowCreateAccountLink()
    {
        if (!$this->getCanAnyoneCreateAccount())
            return false;
        return $this->bShowCreateAccountLink;
    }

    /**
     * used for communicating with the template wether to show the link or not.
     * 
     * 
     * @return bool
     */    
    protected function setShowCreateAccountLink($bShow)
    {
        $this->bShowCreateAccountLink = $bShow;
    }


    protected function getTokenIDSessionCookieKey()
    {
        return $this->sControllerID.TLoginControllerAbstract::SESSIONCOOKIEARRAYKEY_LOGINTOKENID;
    }
    
    protected function getTokenSessionCookieKey()
    {
        return $this->sControllerID.TLoginControllerAbstract::SESSIONCOOKIEARRAYKEY_LOGINTOKENENCRYPTED;
    }

    protected function getFloodDetectionFailedLoginAttemptsKey()
    {
        return $this->sControllerID.TLoginControllerAbstract::SESSIONARRAYKEY_FLOODDETECT_FAILEDLOGINATTEMPTS;
    }
    
    protected function getFloodDetectionSuccessfulLoginAttemptsKey()
    {
        return $this->sControllerID.TLoginControllerAbstract::SESSIONARRAYKEY_FLOODDETECT_SUCCESSFULLOGINATTEMPTS;
    }    
    
    protected function getFloodDetectionPasswordResetAttemptsKey()
    {
        return $this->sControllerID.TLoginControllerAbstract::SESSIONARRAYKEY_FLOODDETECT_PASSWORDRESETATTEMPTS;
    }
    
    protected function getFloodDetectionCreateAccountAttemptsKey()
    {
        return $this->sControllerID.TLoginControllerAbstract::SESSIONARRAYKEY_FLOODDETECT_CREATEACCOUNTATTEMPTS;
    }    

    /**
     * get session array key for the form token
     *
     * @return void
     */
    protected function getFormTokenKey()
    {
        return $this->sControllerID.TLoginControllerAbstract::SESSIONARRAYKEY_FORMTOKEN;
    }    
    
    
    /**
     * determines wether to use a cookie or session
     * 
     * @return boolean true = cookie, false = session
     */
    public function getUseCookie()
    {
        //the _COOKIE array is only set on the next page load, so we can determin to use a cookie by the checkbox
        if ($this->objChkKeepMeLoggedIn)
            return $this->objChkKeepMeLoggedIn->getContentsSubmitted()->getValueAsBool();
        
        //if we have no objChkKeepMeLoggedIn object then look at the cookie
        return isset($_COOKIE[$this->getTokenIDSessionCookieKey()]);
    }
    
    /**
     * retun users db object
     * 
     * @return TUsersAbstract
     */
    public function getUsers()
    {
        return $this->objUsers;
    }
    
    /**
     * return loginattempts db object
     * @return TUsersFloodDetectAbstract
     */
    public function getUsersFloodDetectModel()
    {
        return $this->objUsersFloodDetectModel;
    }
    
    /**
     * return usersessions db object
     * @return TUsersSessionsAbstract
     */
    public function getUserSessions()
    {
        return $this->objUsersSessions;
    }
    
    public function getNewLanguage()
    {
        return new \dr\classes\models\TSysLanguages();
    }
    
    public function getLanguages()
    {
        return $this->objLanguage;
    }

    /**
     * set message that is not an error
     *
     * @param string $sMessage
     * @return void
     */
    protected function setMessageNormal($sMessage)
    {
        $this->sMessageNormal = $sMessage;
    }

    
    /**
     * return message that are not errormessages like "log out successful"
     * 
     * @return string
     */
    public function getMessageNormal()
    {
        return $this->sMessageNormal;
    }
    
    /**
     * set error message
     *
     * @param string $sMessage
     * @return void
     */
    protected function setMessageError($sMessage)
    {
        $this->sMessageError = $sMessage;
    }


    /**
     * return translated error messages like: "login failed"
     * 
     * @return string
     */
    public function getMessageError()
    {
        return $this->sMessageError;
    }

    /**
     * 
     * @return FormGenerator
     */
    public function getFormLogin()
    {
        return $this->objFormLogin;
    }

    /**
     * 
     * @return FormGenerator
     */
    public function getFormPasswordRecover()
    {
        return $this->objFormPassworRecover;
    }    

    /**
     * return form object
     *
     * @return TForm
     */
    public function getFormCreateAccount()
    {
        return $this->objFormCreateAccount;
    }

    
    /**
     * generate the form object and all the UI elements to log in (field username, password, login-button)
     * 
     * we do this as a separate function, because it's only needed when the user
     * tries to login in, not for basic authentication on every page in the cms 
     * for example
     */
    public function populateFormLogin()
    {
        $this->objFormLogin = new FormGenerator('login-'.$this->sControllerID, $this->sURLLoginForm);
        $this->objFormLogin->setRecaptchaV3Use($this->getUseRecapthaLogin());
    
            //form token
        $this->objHDFormToken = new InputHidden();
        $this->objHDFormToken->setNameAndID('hdFT');
        $this->objHDFormToken->setValue($this->generateFormToken()); //we set the value here, otherwise we have to create a new method() for only 1 line
        $this->getFormLogin()->add($this->objHDFormToken);                             

            //username
        $this->objEdtUsername = new InputText();
        $this->objEdtUsername->setNameAndID('edtUsername');
        $this->objEdtUsername->setClass('input_type_text');                 
        $this->objEdtUsername->setRequired(true); 
        $this->objEdtUsername->setMaxLength(255);    
        $objValidator = new Maximumlength(transw('form_error_maxlengthexceeded', 'The maximumlength [length] of this field is exceeded', 'length', '100'), 100);
        $this->objEdtUsername->addValidator($objValidator);        
        $objValidator = new Required(transcms('form_error_requiredfield', 'This is a required field'));
        $this->objEdtUsername->addValidator($objValidator);       
        $objValidator = new Characterwhitelist(transcms('form_error_charactersnotallowed', 'One or more characters are not allowed'), TLoginControllerAbstract::CHARSALLOWED_FORMFIELDS);
        $this->objEdtUsername->addValidator($objValidator);
        $this->getFormLogin()->add($this->objEdtUsername, '', transw('loginform_field_username', 'username')); 


            //password
        $this->objEdtPassword = new InputPassword();
        $this->objEdtPassword->setNameAndID('edtPassword');
        $this->objEdtPassword->setClass('input_type_text');                 
        $this->objEdtPassword->setRequired(true); 
        $this->objEdtPassword->setMaxLength(255);    
        $objValidator = new Maximumlength(transw('form_error_maxlengthexceeded', 'The maximumlength [length] of this field is exceeded', 'length', '100'), 100);
        $this->objEdtPassword->addValidator($objValidator);        
        $objValidator = new Required(transcms('form_error_requiredfield', 'This is a required field'));
        $this->objEdtPassword->addValidator($objValidator);       
        $objValidator = new Characterwhitelist(transcms('form_error_charactersnotallowed', 'One or more characters are not allowed'), TLoginControllerAbstract::CHARSALLOWED_FORMFIELDS);
        $this->objEdtPassword->addValidator($objValidator);
        $this->getFormLogin()->add($this->objEdtPassword, '', transw('loginform_field_password', 'password'));         
        
            //keep-me-logged-in
        if ($this->bUseKeepLoggedIn)
        {
            $this->objChkKeepMeLoggedIn = new InputCheckbox();
            $this->objChkKeepMeLoggedIn->setNameAndID('edtKeepMeLoggedIn');
            $this->getFormLogin()->add($this->objChkKeepMeLoggedIn, '', transw('loginform_field_keepmeloggedin', 'keep me logged in'));        
        }
        

            //submit
        /*
        if (!$this->getUseRecapthaLogin())
        {
            $this->objSubmit = new InputSubmit();    
            $this->objSubmit->setValue(transw('loginform_button_login', 'log in'));
            $this->objSubmit->setNameAndID('btnSubmit');
            $this->objSubmit->setClass('input_type_button');
            $this->getFormLogin()->add($this->objSubmit);
        }
        else
        {
            $this->objSubmitRecaptcha = new InputButton();    
            $this->objSubmitRecaptcha->setValue(transw('loginform_button_login', 'log in'));
            $this->objSubmitRecaptcha->setNameAndID('btnSubmit');
            $this->objSubmitRecaptcha->setClass('g-recaptcha input_type_button');
            $this->objSubmitRecaptcha->setDataSitekey(GLOBAL_GOOGLE_RECAPTCHAV3_SITEKEY);
            $this->objSubmitRecaptcha->setDataCallback('onSubmitRecaptcha');
            $this->objSubmitRecaptcha->setDataAction('submit');
            $this->getFormLogin()->add($this->objSubmitRecaptcha);
        }
        */

        if (!$this->getUseRecapthaLogin())
            $this->objSubmit = new InputSubmit();
        else
            $this->objSubmit = new InputButton();
        $this->objSubmit->setValue(transw('loginform_button_login', 'log in')); 
        $this->objSubmit->setNameAndID('btnSubmit');     
        $this->objSubmit->setClass('input_type_button');   
        $this->getFormLogin()->makeRecaptchaV3SubmitButton($this->objSubmit);  
        $this->getFormLogin()->add($this->objSubmit);
    }

    /**
     * generate the form object and all the UI elements to recover a password (=email address + button)
     * 
     */
    public function populateFormPasswordRecoverEnterEmail()
    {
        $this->objFormPassworRecover = new FormGenerator('passwordrecover-'.$this->sControllerID, $this->sURLPasswordRecoverEnterEmail);
        $this->objFormPassworRecover->setRecaptchaV3Use($this->getUseRecapthaLogin());

            //form token
        $this->objHDFormToken = new InputHidden();
        $this->objHDFormToken->setNameAndID('hdFT');
        $this->objHDFormToken->setValue($this->generateFormToken()); //we set the value here, otherwise we have to create a new method() for only 1 line
        $this->getFormPasswordRecover()->add($this->objHDFormToken);    

            //email address
        $this->objEdtEmailAddress = new InputEmail();
        $this->objEdtEmailAddress->setNameAndID('edtEmailAddress');
        $this->objEdtEmailAddress->setClass('input_type_text');                 
        $this->objEdtEmailAddress->setRequired(true); 
        $this->objEdtEmailAddress->setMaxLength(100);    
        $objValidator = new Emailaddress(transw('form_error_emailnotvalid', 'This is not a valid emailaddress'));
        $this->objEdtEmailAddress->addValidator($objValidator);        
        $objValidator = new Maximumlength(transw('form_error_maxlengthexceeded', 'The maximumlength [length] of this field is exceeded', 'length', '100'), 100);
        $this->objEdtEmailAddress->addValidator($objValidator);        
        $objValidator = new Required(transcms('form_error_requiredfield', 'This is a required field'));
        $this->objEdtEmailAddress->addValidator($objValidator);       
        $this->getFormPasswordRecover()->add($this->objEdtEmailAddress, '', transw('loginform_field_emailaddress', 'email address')); 
        

        //submit
        /*
        if (!$this->getUseRecapthaLogin())
        {
            $this->objSubmit = new InputSubmit();    
            $this->objSubmit->setValue(transw('passwordrecoverform_button_sendemail', 'send email'));
            $this->objSubmit->setNameAndID('btnSubmit');
            $this->objSubmit->setClass('input_type_button');
            $this->getFormPasswordRecover()->add($this->objSubmit);
        }
        else
        {
            $this->objSubmitRecaptcha = new InputButton();    
            $this->objSubmitRecaptcha->setValue(transw('passwordrecoverform_button_sendemail', 'send email'));
            $this->objSubmitRecaptcha->setNameAndID('btnSubmit');
            $this->objSubmitRecaptcha->setClass('g-recaptcha input_type_button');
            $this->objSubmitRecaptcha->setDataSitekey(GLOBAL_GOOGLE_RECAPTCHAV3_SITEKEY);
            $this->objSubmitRecaptcha->setDataCallback('onSubmitRecaptcha');
            $this->objSubmitRecaptcha->setDataAction('submit');
            $this->getFormPasswordRecover()->add($this->objSubmitRecaptcha);
        }
        */
        if (!$this->getUseRecapthaLogin())
            $this->objSubmit = new InputSubmit();
        else
            $this->objSubmit = new InputButton();
        $this->objSubmit->setValue(transw('passwordrecoverform_button_sendemail', 'send email')); 
        $this->objSubmit->setNameAndID('btnSubmit');     
        $this->objSubmit->setClass('input_type_button');   
        $this->getFormPasswordRecover()->makeRecaptchaV3SubmitButton($this->objSubmit);  
        $this->getFormPasswordRecover()->add($this->objSubmit);                    


    }

    /**
     * generate the form object and all the UI elements to create an account
     * (=username, email address, password + button)
     * 
     */
    public function populateFormCreateAccountEnterCredentials()
    {
        $this->objFormCreateAccount = new FormGenerator('createaccount-'.$this->getControllerID(), getURLCreateAccountEnterCredentials());
        $this->objFormCreateAccount->setRecaptchaV3Use($this->getUseRecapthaLogin());

            //form token
        $this->objHDFormToken = new InputHidden();
        $this->objHDFormToken->setNameAndID('hdFT');
        $this->objHDFormToken->setValue($this->generateFormToken()); //we set the value here, otherwise we have to create a new method() for only 1 line
        $this->objFormCreateAccount->add($this->objHDFormToken);    
                
            //username
        $this->objEdtUsername = new InputText();
        $this->objEdtUsername->setNameAndID('edtUsername');
        $this->objEdtUsername->setClass('input_type_text');                 
        $this->objEdtUsername->setRequired(true); 
        $this->objEdtUsername->setMaxLength(255);    
        $objValidator = new Maximumlength(transw('form_error_maxlengthexceeded', 'The maximumlength [length] of this field is exceeded', 'length', '100'), 100);
        $this->objEdtUsername->addValidator($objValidator);        
        $objValidator = new Required(transcms('form_error_requiredfield', 'This is a required field'));
        $this->objEdtUsername->addValidator($objValidator);       
        // $objValidator = new Characterwhitelist(transcms('form_error_charactersnotallowed', 'One or more characters are not allowed'), TLoginControllerAbstract::CHARSALLOWED_FORMFIELDS);
        // $this->objEdtUsername->addValidator($objValidator);
        $this->objFormCreateAccount->add($this->objEdtUsername, '', transw('createaccountform_field_username', 'Username')); 
    
        

            //email address
        $this->objEdtEmailAddress = new InputEmail();
        $this->objEdtEmailAddress->setNameAndID('edtEmailAddress');
        $this->objEdtEmailAddress->setClass('input_type_text');                 
        $this->objEdtEmailAddress->setRequired(true); 
        $this->objEdtEmailAddress->setMaxLength(100);    
        $objValidator = new Emailaddress(transw('form_error_emailnotvalid', 'This is not a valid emailaddress'));
        $this->objEdtEmailAddress->addValidator($objValidator);        
        $objValidator = new Maximumlength(transw('form_error_maxlengthexceeded', 'The maximumlength [length] of this field is exceeded', 'length', '100'), 100);
        $this->objEdtEmailAddress->addValidator($objValidator);        
        $objValidator = new Required(transcms('form_error_requiredfield', 'This is a required field'));
        $this->objEdtEmailAddress->addValidator($objValidator);       
        $this->objFormCreateAccount->add($this->objEdtEmailAddress, '', transw('createaccountform_field_emailaddress', 'Email address')); 
        

            //password
        $this->objEdtPassword = new InputPassword();
        $this->objEdtPassword->setNameAndID('edtPassword');
        $this->objEdtPassword->setClass('input_type_text');                 
        $this->objEdtPassword->setRequired(true); 
        $this->objEdtPassword->setMaxLength(255);    
        $objValidator = new Maximumlength(transw('form_error_maxlengthexceeded', 'The maximumlength [length] of this field is exceeded', 'length', '100'), 100);
        $this->objEdtPassword->addValidator($objValidator);        
        $objValidator = new Required(transcms('form_error_requiredfield', 'This is a required field'));
        $this->objEdtPassword->addValidator($objValidator);       
        $objValidator = new StrongPassword(transw('form_error_didusestrongpassword', 'Your password isn\'t strong enough. A strong password has:[rules]', 'rules', implode(' ', StrongPassword::getRules())));
        $this->objEdtPassword->addValidator($objValidator);        
        $objValidator = new Characterwhitelist(transcms('form_error_charactersnotallowed', 'One or more characters are not allowed'), TLoginControllerAbstract::CHARSALLOWED_FORMFIELDS);
        $this->objEdtPassword->addValidator($objValidator);
        $this->objFormCreateAccount->add($this->objEdtPassword, '', transw('createaccount_field_password', 'Password'));         

        
            //confirm password
        $this->objEdtPasswordRepeat = new InputPassword();
        $this->objEdtPasswordRepeat->setNameAndID('edtPasswordConfirm');
        $this->objEdtPasswordRepeat->setClass('input_type_text');                 
        $this->objEdtPasswordRepeat->setRequired(true); 
        $objValidator = new Repeatfieldvalue(transw('form_error_passwordsnotsame', 'The passwords in the password fields do not match'), $this->objEdtPassword);
        $this->objEdtPasswordRepeat->addValidator($objValidator);                
        $this->objFormCreateAccount->add($this->objEdtPasswordRepeat, '', transw('createaccount_field_passwordrepeat', 'Repeat password'));         
    
        
            //populate by child class
        $this->populateFormCreateAccountEnterCredentialsChild();


        //submit
        /*
        if (!$this->getUseRecapthaLogin())
        {
            $this->objSubmit = new InputSubmit();    
            $this->objSubmit->setValue(transw('createnewaccountform_button_sendemail', 'Submit'));
            $this->objSubmit->setNameAndID('btnSubmit');
            $this->objSubmit->setClass('input_type_button');
            $this->objFormCreateAccount->add($this->objSubmit);
        }
        else
        {
            $this->objSubmitRecaptcha = new InputButton();    
            $this->objSubmitRecaptcha->setValue(transw('createnewaccountform_button_sendemail', 'Submit'));
            $this->objSubmitRecaptcha->setNameAndID('btnSubmit');
            $this->objSubmitRecaptcha->setClass('g-recaptcha input_type_button');
            $this->objSubmitRecaptcha->setDataSitekey(GLOBAL_GOOGLE_RECAPTCHAV3_SITEKEY);
            $this->objSubmitRecaptcha->setDataCallback('onSubmitRecaptcha');
            $this->objSubmitRecaptcha->setDataAction('submit');
            $this->objFormCreateAccount->add($this->objSubmitRecaptcha);
        }       
        */
        if (!$this->getUseRecapthaLogin())
            $this->objSubmit = new InputSubmit();
        else
            $this->objSubmit = new InputButton();
        $this->objSubmit->setValue(transw('createnewaccountform_button_sendemail', 'Submit')); 
        $this->objSubmit->setNameAndID('btnSubmit');     
        $this->objSubmit->setClass('input_type_button');   
        $this->objFormCreateAccount->makeRecaptchaV3SubmitButton($this->objSubmit);  
        $this->objFormCreateAccount->add($this->objSubmit);        
        
    }    

    /**
     * generate the form object and all the UI elements to recover a password (=password + button)
     * 
     */
    public function populateFormPasswordRecoverEnterPassword()
    {
        $this->objFormPassworRecover = new FormGenerator('passwordrecover-'.$this->sControllerID, $this->sURLPasswordRecoverEnterPassword);
        $this->objFormPassworRecover->setRecaptchaV3Use($this->getUseRecapthaLogin());

            //form token
        $this->objHDFormToken = new InputHidden();
        $this->objHDFormToken->setNameAndID('hdFT');
        $this->objHDFormToken->setValue($this->generateFormToken()); //we set the value here, otherwise we have to create a new method() for only 1 line
        $this->getFormPasswordRecover()->add($this->objHDFormToken);    

            //user randomid
        $this->objHdUserRandomID = new InputHidden();
        $this->objHdUserRandomID->setNameAndID('hdID1'); //deliberately vague name
        $this->objHdUserRandomID->setValueSubmitted($this->getFormPasswordRecover()->getForm()->getMethod());//bring over the values from the old (failed) form to the new form
        if (isset($_GET[TLoginControllerAbstract::GETARRAYKEY_USER_RANDOMID]))
            $this->objHdUserRandomID->setValue($_GET[TLoginControllerAbstract::GETARRAYKEY_USER_RANDOMID]);
        $this->getFormPasswordRecover()->add($this->objHdUserRandomID);                 

            //email token
        $this->objHdEmailToken = new InputHidden();
        $this->objHdEmailToken->setNameAndID('hdID2'); //deliberately vague name
        $this->objHdEmailToken->setValueSubmitted($this->getFormPasswordRecover()->getForm()->getMethod());//bring over the values from the old (failed) form to the new form
        if (isset($_GET[TLoginControllerAbstract::GETARRAYKEY_USER_EMAILTOKEN]))
            $this->objHdEmailToken->setValue($_GET[TLoginControllerAbstract::GETARRAYKEY_USER_EMAILTOKEN]);            
        $this->getFormPasswordRecover()->add($this->objHdEmailToken);                 
    
            //hashed username
        $this->objHdUsernameHashed = new InputHidden();
        $this->objHdUsernameHashed->setNameAndID('hdID3'); //deliberately vague name
        $this->objHdUsernameHashed->setValueSubmitted($this->getFormPasswordRecover()->getForm()->getMethod()); //bring over the values from the old (failed) form to the new form
        if (isset($_GET[TLoginControllerAbstract::GETARRAYKEY_USER_USERNAME]))
            $this->objHdUsernameHashed->setValue($_GET[TLoginControllerAbstract::GETARRAYKEY_USER_USERNAME]);            
        $this->getFormPasswordRecover()->add($this->objHdUsernameHashed);                 

            //password
        $this->objEdtPassword = new InputPassword();
        $this->objEdtPassword->setNameAndID('edtPassword');
        $this->objEdtPassword->setClass('input_type_text');                 
        $this->objEdtPassword->setRequired(true); 
        $this->objEdtPassword->setMaxLength(255);    
        $objValidator = new Maximumlength(transw('form_error_maxlengthexceeded', 'The maximumlength [length] of this field is exceeded', 'length', '100'), 100);
        $this->objEdtPassword->addValidator($objValidator);        
        $objValidator = new Required(transcms('form_error_requiredfield', 'This is a required field'));
        $this->objEdtPassword->addValidator($objValidator);       
        $objValidator = new StrongPassword(transw('form_error_didusestrongpassword', 'Your password isn\'t strong enough. A strong password has:[rules]', 'rules', implode(' ', StrongPassword::getRules())));
        $this->objEdtPassword->addValidator($objValidator);      
        $objValidator = new Characterwhitelist(transcms('form_error_charactersnotallowed', 'One or more characters are not allowed'), TLoginControllerAbstract::CHARSALLOWED_FORMFIELDS);
        $this->objEdtPassword->addValidator($objValidator);
        $this->getFormPasswordRecover()->add($this->objEdtPassword, '', transw('passwordrecover_field_password', 'password'));         

            //confirm password
        $this->objEdtPasswordRepeat = new InputPassword();
        $this->objEdtPasswordRepeat->setNameAndID('edtPasswordConfirm');
        $this->objEdtPasswordRepeat->setClass('input_type_text');                 
        $this->objEdtPasswordRepeat->setRequired(true); 
        $objValidator = new Repeatfieldvalue(transw('form_error_passwordsnotsame', 'The passwords in the password fields do not match'), $this->objEdtPassword);
        $this->objEdtPasswordRepeat->addValidator($objValidator);                
        $this->getFormPasswordRecover()->add($this->objEdtPasswordRepeat, '', transw('createaccount_field_passwordrepeat', 'Repeat password'));         


        //submit
        /*
        if (!$this->getUseRecapthaLogin())
        {
            $this->objSubmit = new InputSubmit();    
            $this->objSubmit->setValue(transw('passwordrecoverform_button_changepassword', 'change password'));
            $this->objSubmit->setNameAndID('btnSubmit');
            $this->objSubmit->setClass('input_type_button');
            $this->getFormPasswordRecover()->add($this->objSubmit);
        }
        else
        {
            $this->objSubmitRecaptcha = new InputButton();    
            $this->objSubmitRecaptcha->setValue(transw('passwordrecoverform_button_changepassword', 'change password'));
            $this->objSubmitRecaptcha->setNameAndID('btnSubmit');
            $this->objSubmitRecaptcha->setClass('g-recaptcha input_type_button');
            $this->objSubmitRecaptcha->setDataSitekey(GLOBAL_GOOGLE_RECAPTCHAV3_SITEKEY);
            $this->objSubmitRecaptcha->setDataCallback('onSubmitRecaptcha');
            $this->objSubmitRecaptcha->setDataAction('submit');
            $this->getFormPasswordRecover()->add($this->objSubmitRecaptcha);
        }        
        */  
        if (!$this->getUseRecapthaLogin())
            $this->objSubmit = new InputSubmit();
        else
            $this->objSubmit = new InputButton();
        $this->objSubmit->setValue(transw('passwordrecoverform_button_changepassword', 'change password')); 
        $this->objSubmit->setNameAndID('btnSubmit');     
        $this->objSubmit->setClass('input_type_button');   
        $this->getFormPasswordRecover()->makeRecaptchaV3SubmitButton($this->objSubmit);  
        $this->getFormPasswordRecover()->add($this->objSubmit);        
    }    

    /**
     * transfer database elements to form
     * 
     * (the namegiving is because of consistency with other controllers, there is not a lot of 'model' in 'modelToForm')
     */
    protected function modelToFormCreateAccountEnterCredentials()
    {  
        $this->objEdtUsername->setValueSubmitted($this->objFormCreateAccount->getForm()->getMethod());
        $this->objEdtEmailAddress->setValueSubmitted($this->objFormCreateAccount->getForm()->getMethod());



        $this->modelToFormCreateAccountEnterCredentialsChild();
    }



    /**
     * generates a new form token and saves it in the session.
     * You can check if a formtoken is valid with this function: isFormTokenValid()
     *
     * @return string
     */
    protected function generateFormToken()
    {
        $sNewToken = '';
        $sNewToken = generatePassword(50, 100);
        $sNewToken = password_hash($sNewToken, PASSWORD_DEFAULT);
        if (isset($_SESSION[$this->sAKFormToken]))
            $_SESSION[$this->sAKFormToken][] = $sNewToken;
        else
            $_SESSION[$this->sAKFormToken] = array($sNewToken);

        return $sNewToken;
    }

    /**
     * checks if form token is registered in the past by .
     * Use this function once you receive values from a form (token from a form is considered a dirty token)
     *
     * @param string $sDirtyToken
     * @return boolean
     */
    protected function isValidFormToken($sDirtyToken)
    {
        if (isset($_SESSION[$this->sAKFormToken]))
        {
            if (is_array($_SESSION[$this->sAKFormToken]))
            {
                return in_array($sDirtyToken, $_SESSION[$this->sAKFormToken]);
            }
            else
                return false;
        }
        else
            return false;
    }

    /**
     * remove all formtokens from session created with .
     *
     * @return void
     */
    protected function clearFormTokens()
    {
        unset($_SESSION[$this->sAKFormToken]);
    }
            
    /**
     * handle account creation when user clicked on link in email
     * 
     */
    public function handleCreateAccountEmailConfirmed()
    {
        $bResult = true;        
        $iUserRandomID = 0;
        $sEmailTokenDecrypted = '';
        $sUsernameHashed = '';


        //if creating accounts is switched off
        if ($this->getCanAnyoneCreateAccount() === false) 
        {
            $this->objFormCreateAccount = null;
            $this->setMessageError(transw('logincontroller_createaccount_errormessage_creatingaccountdisabled', 'Sorry, regretfully it is not possible to create an account at this moment.')); 
            return false;
        }


        //we want to run all the checks on form called and form submitted to prevent fraud
        if (is_numeric($_GET[TLoginControllerAbstract::GETARRAYKEY_USER_RANDOMID])) //force numeric, otherwise will default to 0
            $iUserRandomID = $_GET[TLoginControllerAbstract::GETARRAYKEY_USER_RANDOMID];
        $sEmailTokenDecrypted = $_GET[TLoginControllerAbstract::GETARRAYKEY_USER_EMAILTOKEN];
        $sUsernameHashed = $_GET[TLoginControllerAbstract::GETARRAYKEY_USER_USERNAME];



        //we start here with all the checks
        if (!$this->detectFloodAll()) //extra strict flood detection
        {           
            $objUsersTemp = null;
            $objUsersTemp = $this->getUsers()->getCopy();

            $objUsersTemp->find(TUsersAbstract::FIELD_RANDOMID, $iUserRandomID);
            $objUsersTemp->limitOne();
            $objUsersTemp->loadFromDB();    

            if ($objUsersTemp->count() == 1)
            {

                //check for validity token
                if (
                    ($objUsersTemp->isValidEmailToken($sEmailTokenDecrypted)) 
                    && 
                    (password_verify($objUsersTemp->getUsername(), $sUsernameHashed)) 
                    )
                {
                    //check for email token expiration
                    if ($objUsersTemp->getEmailTokenExpires()->isInTheFuture())
                    {

                        //enable account
                        $objUsersTemp->setEmailTokenEmpty();
                        $objUsersTemp->setEmailTokenExpires();
                        $objUsersTemp->setLoginEnabled(true);   
                        $objUsersTemp->setDeleteAfter();

                        if ((int)(getSetting(SETTINGS_MODULE_CMS, SETTINGS_CMS_MEMBERSHIP_USERPASSWORDEXPIRES_DAYS)) == 0)
                        {
                            $objUsersTemp->setPasswordExpires();
                        }
                        else
                        {
                            $objTempExpirePassword = new TDateTime(time());
                            $objTempExpirePassword->addDays((int)getSetting(SETTINGS_MODULE_CMS, SETTINGS_CMS_MEMBERSHIP_USERPASSWORDEXPIRES_DAYS));
                            $objUsersTemp->setPasswordExpires($objTempExpirePassword);
                            unset($objTempExpirePassword);
                        }


                        if ($objUsersTemp->saveToDB())
                        {
                            $this->setMessageNormal(transw('logincontroller_message_handleaccountcreation_accountactivated', 'Account succesfully activated!<br>Click on the link below to log in with your credentials'));
                            $bResult = true;
                        }
                        else
                        {
                            $this->setMessageError(transw('logincontroller_errormessage_handleaccountcreation_errorsave_accountnotactivated', 'Error saving. Account NOT activated!')); //we are deliberately vague for security reasons
                            $bResult = false;    
                        }

                    }
                    else // email token expired
                    {
                        $this->setMessageError(transw('logincontroller_errormessage_handleaccountcreation_emailtokenexpired', 'Sorry, your activation timed out! Create another account. The current account is scheduled for deletion.')); 
                        $bResult = false;        
                    }
                }
                else //login token not correct
                {
                    $this->setMessageError(transw('logincontroller_errormessage_handleaccountcreation_emailtokennotcorrect', 'Something went wrong with activating your account.')); //we are deliberately vague for security reasons
                    $bResult = false;    
                }
            }
            else //no records found in db
            {
                $this->setMessageError(transw('logincontroller_errormessage_handleaccountcreation_usernotfound', 'Something went wrong with the user. Account NOT activated!')); //we are deliberately vague for security reasons
                $bResult = false;
            }

        } //end  no flood detection
        else    //flood detected       
        {            
            $this->setMessageError(transw('logincontroller_errormessage_handleaccountcreation_flooddetected', 'Sorry, account NOT activated for security reasons.'));
            $this->objFormLogin = null; //prevent attacker from logging in 
            $this->objFormPassworRecover = null; //prevent attacker from recovering password
            $bResult = false; 
        }   

        
        return $bResult;      
    }
     
    
    /**
     * the user tries to log in, handle the authentication and send to the right pages (success or failed)
     * if form is not submitted, this function does nothing.
     */
    public function handleLoginLogout()
    {
        // logDebug(__CLASS__.': '.__FUNCTION__.': '.__LINE__,'start');
                

        //with too many failed login attempts we still want to show the create-account and password-recover link
        if (!$this->detectFloodFailedLoginAttempts())
        {
            if ((!$this->detectFloodGeneric()) && (!$this->detectFloodSuccessFulLoginAttempts()))
            {        
                if (!$this->isLoggingOut())
                {
                    $this->handleLogIn();
                }
                else //is in the process of logging out?
                {
                    $this->handleLogOut();
                }
            }//end: flood detection
            else
            {            
                $this->sMessageError = transw('logincontroller_message_toomanyattempts', 'It is very busy right now, try again later.');
                $this->objFormLogin = null; //prevent attacker from logging in 
                $this->objFormPassworRecover = null; //prevent attacker from recovering password
                $this->setShowCreateAccountLink(false);
                $this->setShowPasswordRecoverLink(false);   
                preventTimingAttack(100,400);
            }
        }
        else
        {
            $this->sMessageError = transw('logincontroller_message_toomanyfailedloginattempts', 'Too many failed login attempts, your ability to login is temporarily suspended. try again later.');
            $this->objFormLogin = null; //prevent attacker from logging in 
            $this->setShowCreateAccountLink(false);
            $this->setShowPasswordRecoverLink(true);
            preventTimingAttack(100, 250);
        }

    }



    
    /**
     * handles user authentication on every page
     * 
     * the function authenticate() does only a checks but does no referals to 
     * other pages, this function does
     */
    public function handleAuthentication()
    {
        global $sCurrentModule;
        $bResult = false;
        // logDebug(__CLASS__.': '.__FUNCTION__.': '.__LINE__,'start');        
        $bResult = $this->authenticate(); //auth this object
        
        // preventTimingAttack(50, 200);

        if (!$bResult) //when authentication failed, get out of here
        {
            $sUserName = '?';
            if ($this->objUsers)
                $sUserName = $this->objUsers->getUsername();
            logAccess(__CLASS__.': '.__FUNCTION__.': '.__LINE__, 'user: '.$sUserName.' --> Login session expired on page: '.getURLThisScript().' . $this->authenticate() returned false. Go to Location: '.$this->sURLLoginForm);

            // logDebug(__CLASS__.': '.__FUNCTION__.': '.__LINE__,'authentication failed, goto Location: '.$this->sURLLoginForm);
            // logDebug(__CLASS__.': '.__FUNCTION__.': '.__LINE__, 'header redirect 1');
            header('HTTP/1.0 401 Unauthorized');
            header('Location: '.addVariableToURL($this->sURLLoginForm, TLoginControllerAbstract::GETARRAYKEYMESSAGEERROR, transw('logincontroller_sessionexpired', 'Login session expired')));            
            die();
        }        
        
        //handle additional authentication by child object
        if ($bResult)
        {            
            $bResult = $this->handleAuthenticationChild();

            if (!$bResult)
            {
                $sUserName = '?';
                if ($this->objUsers)
                    $sUserName = $this->objUsers->getUsername();
    
                logAccess(__CLASS__.': '.__FUNCTION__.': '.__LINE__, 'user: '.$sUserName.' --> $this->handleAuthenticationChild() returned false');
            }
        }

        
        return $bResult;
    }


    /**
     * handle password recovery when entered email address and clicked on 'recover' button
     */
    public function handlePassworRecoverEnterEmail()
    {
        $bResult = false;
        $sEmailAddress = '';
        $sHTMLContentMain = ''; //for email skin
        $sHTMLEmailTemplateSkin = '';
        $sNewEmailTokenDecrypted = '';
        $sHashedUsername = '';

        //form submitted?
        if ($this->getFormPasswordRecover()->isFormSubmitted())
        {            
            if ($this->getFormPasswordRecover()->isValid()) 
            {
                /*
                if (!$this->isRecaptchaValid())
                {
                    $this->registerPasswordReset(); //needs to be registered BEFORE the flood detection                
                    $this->setMessageError(transw('logincontroller_errormessage_passwordrecoverenteremail_recaptchafailed', 'Recaptcha failed sorry'));             
                    preventTimingAttack(100,600);
                    return false;
                }
                */
    
                $this->registerPasswordReset(); //needs to be registered BEFORE the flood detection                

                if ($this->isValidFormToken($this->objHDFormToken->getContentsSubmitted()->getValueAsString()))
                {
                    if ((!$this->detectFloodPasswordResetAttempts()) && (!$this->detectFloodGeneric()))
                    {           
                        $objUsersTemp = null;
                        $iCountMatchesEmailAddresses = 0;
                        $objUsersTemp = $this->getUsers()->getCopy();
                        $sEmailAddress = $this->objEdtEmailAddress->getContentsSubmitted()->getValueAsString();

                        //the html validator is supposed to check it before, but for extra security: we check it again
                        if (isValidEmail($sEmailAddress))
                        {                 
                            $objUsersTemp->clear();
                            $objUsersTemp->find(TUsersAbstract::FIELD_EMAILADDRESSFINGERPRINT, $objUsersTemp->generateFingerprintEmail($sEmailAddress));
                            $objUsersTemp->loadFromDB();

                            //from fingerprints: count email address matches in database
                            while ($objUsersTemp->next())
                            {   
                                ///I want to make 100% sure that the emailaddress matches the encrypted email address, 
                                //different email addresses technically could generate the same fingerprint (although rare)
                                if ($objUsersTemp->isMatchUncryptedValue(TUsersAbstract::FIELD_EMAILADDRESSENCRYPTED, $sEmailAddress))
                                    $iCountMatchesEmailAddresses++;
                            }


                            //if email found in database
                            if ($iCountMatchesEmailAddresses > 0)
                            {
                                $objTempExpireToken = new TDateTime(time());
                                $objTempExpireToken->addHour(1);        
                                $sNewEmailTokenDecrypted = password_hash(generatePassword(10, 50), PASSWORD_DEFAULT); //the hash to add extra randomness
                                $sHashedUsername = password_hash($objUsersTemp->getUsername(), PASSWORD_DEFAULT); 
                                $objUsersTemp->setEmailTokenDecrypted($sNewEmailTokenDecrypted);
                                $objUsersTemp->setEmailTokenExpires($objTempExpireToken);
                                $objUsersTemp->saveToDB();

                                //set email variables
                                $sApplicationName = $this->getApplicationName();
                                $sURLPasswordRecover = $this->sURLPasswordRecoverEnterPassword;
                                $sURLPasswordRecover = addVariableToURL($sURLPasswordRecover,TLoginControllerAbstract::GETARRAYKEY_USER_RANDOMID, $objUsersTemp->getRandomID());
                                $sURLPasswordRecover = addVariableToURL($sURLPasswordRecover,TLoginControllerAbstract::GETARRAYKEY_USER_EMAILTOKEN, $sNewEmailTokenDecrypted);
                                $sURLPasswordRecover = addVariableToURL($sURLPasswordRecover,TLoginControllerAbstract::GETARRAYKEY_USER_USERNAME, $sHashedUsername);
                                $sUserName = $objUsersTemp->getUsername();
                                $sHTMLContentMain = renderTemplate($this->getPathEmailTemplatePasswordRecover(), get_defined_vars());
                                $sHTMLEmailTemplateSkin = renderTemplate($this->getPathEmailSkin(), get_defined_vars());
                            
                                
                                $objMail = new TMailSend();
                                $objMail->setTo($sEmailAddress, $sUserName);
                                $objMail->setFrom($this->sMailbotFromEmailAddress, $this->sMailbotFromName);
                                $objMail->setSubject(transw('logincontroller_passwordrecover_email_subject_resetpassword', 'Your password reset request'));
                                $objMail->setBody($sHTMLEmailTemplateSkin, true);
                                if ($objMail->send())
                                {
                                    $bResult = true;//we want to let the user to know that everything is ok
                                }
                                else
                                {
                                    $this->setMessageError(transw('logincontroller_resetpassword_message_emailerror', 'An error has occured sending your email.'));
                                    error_log('EMAIL ERROR: '.__CLASS__.' '.$objMail->getErrorMessage());
                                    $bResult = false;//we want to let the user know: error
                                }
                                
                                
                            }
                            else //email NOT found in DB
                            {
                                //we DON'T show a message that the email wasn't found in the database for security reasons
                                //someone could 'peek' in the database this way and then brute force attack user accounts with that email address
                                // $this->sMessageError = transw('logincontroller_errormessage_emailnotindatabase', 'Email address does not exist in database');                        
                                //the message to the user is send later (see below)

                                preventTimingAttack(10,450);

                                $bResult = true;//we want to let the user to know that everything is ok
                            }

                            //deliberately it says also OK when emailaddress was NOT found in database (security reasons described above)
                            if ($bResult)
                            {
                                $this->objFormPassworRecover = null;
                                $this->sMessageNormal = transw('logincontroller_passwordrecover_message_emailsent', 'An email was sent to the registered user (if the user is present in our system)');
                            }
                            else
                                $this->sMessageError = transw('logincontroller_passwordrecover_message_somethingwrong', 'Oops, something went wrong');

                        }
                        else //this reeks of an attack
                        {
                            $this->sMessageError = transw('logincontroller_passwordrecover_message_handlepasswordrecover_emailaddressnotvalid', 'This is not a valid email address');
                            $bResult = false;  
                        }

                    } //end  no flood detection
                    else    //flood detected       
                    {            
                        $this->sMessageError = transw('logincontroller_message_handlepasswordrecover_flooddetected', 'Submission not processed for security reasons');
                        $this->objFormLogin = null; //prevent attacker from logging in 
                        $this->objFormPassworRecover = null; //prevent attacker from recovering password
                        $bResult = false; 
                    }   
                }   
                else
                {
                    $this->sMessageError = transw('logincontroller_errormessage_handlepasswordrecover_formtokeninvalid', 'The form submission expired or form authentication failed. Most likely the time between page load and form submission was too long.');//I want to be discrete about the formtoken for security reasons
                    $this->objFormLogin = null; //prevent attacker from logging in 
                    $this->objFormPassworRecover = null; //prevent attacker from recovering password
                    $bResult = false; 
                }
            }
            else
            {
                //showing a form is always quicker than database actions when successfull, 
		        //to keep some mystery about what is going on behind the scenes, slow down the form errors
		        preventTimingAttack(0,200);

                $this->setMessageError(transw('logincontroller_errormessage_handlepasswordresetenteremail_correctinputerrors', 'Please correct input errors')); 
                $bResult = false;               
            }
        }
        
        return $bResult;
    }

    /**
     * handle password recovery: when user has to enter or just entered a new password
     */
    public function handlePassworRecoverEnterPassword()
    {
        $bResult = true;        
        $iUserRandomID = 0;
        $sEmailTokenDecrypted = '';
        $sUsernameHashed = '';

        //we want to run all the checks on form called and form submitted to prevent fraud
        if ($this->getFormPasswordRecover()->isFormSubmitted())
        {

            //get submitted values for later
            if (is_numeric($this->objHdUserRandomID->getContentsSubmitted()->getValueAsInt())) //force numeric, otherwise will default to 0
                $iUserRandomID = $this->objHdUserRandomID->getContentsSubmitted()->getValueAsInt();
            $sEmailTokenDecrypted = $this->objHdEmailToken->getContentsSubmitted()->getValueAsString();
            $sUsernameHashed = $this->objHdUsernameHashed->getContentsSubmitted()->getValueAsString();

            /*
            if (!$this->isRecaptchaValid())
            {
                $this->registerPasswordReset(); //needs to be registered BEFORE the flood detection                
                $this->setMessageError(transw('logincontroller_errormessage_passwordrecoverenteremail_recaptchafailed', 'Recaptcha failed sorry'));             
                preventTimingAttack(100,400);
                return false;
            }
            */

            //check valid form 
            if (!$this->getFormPasswordRecover()->isValid()) 
            {
                $this->sMessageError = transw('logincontroller_errormessage_passwordrecover_enterpassword_correctinput', 'Please correct input errors');
                preventTimingAttack(100,400);                
                return false; //directly go away!
            }    

            //check form token
            if (!$this->isValidFormToken($this->objHDFormToken->getContentsSubmitted()->getValueAsString()))
            {
                $this->sMessageError = transw('logincontroller_errormessage_passwordrecover_enterpassword_formtokeninvalid', 'The form submission expired or form authentication failed. Most likely the time between page load and form submission was too long.');//I want to be discrete about the formtoken for security reasons
                $this->objFormPassworRecover = null; //prevent attacker from recovering password                
                preventTimingAttack(100,400);  
                return false; //directly go away!
            }            

            
        }
        else
        {
            if (isset($_GET[TLoginControllerAbstract::GETARRAYKEY_USER_RANDOMID]))
            {
                if (is_numeric($_GET[TLoginControllerAbstract::GETARRAYKEY_USER_RANDOMID])) //force numeric, otherwise will default to 0
                    $iUserRandomID = $_GET[TLoginControllerAbstract::GETARRAYKEY_USER_RANDOMID];
                $sEmailTokenDecrypted = $_GET[TLoginControllerAbstract::GETARRAYKEY_USER_EMAILTOKEN];
                $sUsernameHashed = $_GET[TLoginControllerAbstract::GETARRAYKEY_USER_USERNAME];
            }
            else
            {
                $this->sMessageError = transw('logincontroller_errormessage_passwordrecover_enterpassword_GETarrayUserIDempty', 'Sorry, couldn\'t identify user');//I want to be discrete about the exact reason
                return false;
            }
            
        }


        //we start here with all the checks
        if ((!$this->detectFloodPasswordResetAttempts()) && (!$this->detectFloodGeneric())) //we only want password attempts and generic attempts, otherwise when you have exceeded max inlog attempts it will also block here
        {           
            $objUsersTemp = null;
            $objUsersTemp = $this->getUsers()->getCopy();

            $objUsersTemp->find(TUsersAbstract::FIELD_RANDOMID, $iUserRandomID);
            $objUsersTemp->limitOne();
            $objUsersTemp->loadFromDB();    

            if ($objUsersTemp->count() == 1)
            {

                //check for validity token
                if (
                    ($objUsersTemp->isValidEmailToken($sEmailTokenDecrypted)) 
                    && 
                    (password_verify($objUsersTemp->getUsername(), $sUsernameHashed)) 
                    )
                {
                    //check for email token expiration
                    if ($objUsersTemp->getEmailTokenExpires()->isInTheFuture())
                    {

                        //form submitted? then save the password
                        if ($this->getFormPasswordRecover()->isFormSubmitted())
                        {
                            $objUsersTemp->setEmailTokenEmpty();
                            $objUsersTemp->setEmailTokenExpires();
                            $objUsersTemp->setPasswordDecrypted($this->objEdtPassword->getContentsSubmitted()->getValueAsString());
                            if ($objUsersTemp->saveToDB())
                            {
                                $this->sMessageNormal = transw('logincontroller_message_handlepasswordrecover_passwordchanged', 'Password successfully changed!'); //we are deliberately vague for security reasons
                                $bResult = true;
                            }
                            else
                            {
                                $this->sMessageError = transw('logincontroller_message_handlepasswordrecover_errorsave_passwordnotchanged', 'Error saving. Password NOT changed!'); //we are deliberately vague for security reasons
                                $bResult = false;    
                            }
                        }
                    }
                    else // email token expired
                    {
                        $this->sMessageError = transw('logincontroller_errormessage_handlepasswordrecover_emailtokenexpired', 'Sorry, your request timed out!'); 
                        $bResult = false;        
                    }
                }
                else //login token not correct
                {
                    $this->sMessageError = transw('logincontroller_errormessage_handlepasswordrecover_emailtokennotcorrect', 'Something went wrong with changing your password. Password NOT changed!'); //we are deliberately vague for security reasons
                    $bResult = false;    
                }
            }
            else //no records found in db
            {
                $this->sMessageError = transw('logincontroller_errormessage_handlepasswordrecover_usernotfound', 'Something went wrong with the user. Password NOT changed!'); //we are deliberately vague for security reasons
                $bResult = false;
            }

        } //end  no flood detection
        else    //flood detected       
        {            
            $this->sMessageError = transw('logincontroller_erroressage_handlepasswordrecover_flooddetected', 'Password NOT changed! You tried to change your password too many times.');
            $this->objFormLogin = null; //prevent attacker from logging in 
            $this->objFormPassworRecover = null; //prevent attacker from recovering password
            $bResult = false; 
        }   

        //remove form if form is submitted OR error occured
        if ($this->getFormPasswordRecover()) //can be null on error
            if ($this->getFormPasswordRecover()->isFormSubmitted() || (!$bResult))
                $this->objFormPassworRecover = null;
        
        return $bResult;        
    }
    

    /**
     * if a user tried to create an account but the email address is already in use with another user
     * instead of showing an error (and giving away to the outside world that we have this email address in our database)
     * we send an email to remind the user that they can reset their password
     *
     * @param string $sEmailAddress
     * @param string $sUsername
     * @return void
     */
    private function handleCreateAccountEnterCredentialsEmailaddressExists($sEmailAddress, $sUsername)
    {
        $bResult = false;

        //setting email variables
        $sApplicationName = $this->getApplicationName();
        $sURLResetPassword = $this->getURLPasswordRecoverEnterEmail();
        $sURLLogin = $this->getURLLoginForm();
        $sHTMLContentMain = renderTemplate($this->getPathEmailTemplateCreateAccountEmailExists(), get_defined_vars());
        $sHTMLEmailTemplateSkin = renderTemplate($this->getPathEmailSkin(), get_defined_vars());
                            
        $objMail = new TMailSend();
        $objMail->setTo($sEmailAddress, $sUsername);
        $objMail->setFrom($this->getMailbotFromEmailAddress(), $this->getMailbotFromName());
        $objMail->setSubject(transw('logincontroller_createaccount_email_subject_emailaddressexists', 'Your emailaddress already exists with an associated [applicationname] account', 'applicationname', $this->getApplicationName()));
        $objMail->setBody($sHTMLEmailTemplateSkin, true);
        if ($objMail->send())
        {
            $this->setMessageNormal(transw('logincontroller_createaccount_emailaddressexists_message_emailsent', 'An email was sent to [emailaddress] with instructions.', 'emailaddress', $sEmailAddress));
            $bResult = true;//we want to let the user to know that everything is ok
        }
        else
        {
            $this->setMessageError(transw('logincontroller_createaccount_emailaddressexists_message_emailerror', 'An error has occured sending your email.'));
            error_log('EMAIL ERROR: '.__CLASS__.' '.$objMail->getErrorMessage());
            $bResult = false;//we want to let the user know: error
        }          

        return $bResult;
    }


    /**
     * handle account creation when user creates a new account
     * 
     * this is done in the cms controller since we want to use some extra features of the cms
     * like language, the default usergroup
     */
    public function handleCreateAccountEnterCredentials()
    {
        $bResult = false;
        $sEmailAddress = '';
        $sNewEmailTokenDecrypted = '';
        $sHashedUsername = '';

        //if creating accounts is switched off
        if ($this->getCanAnyoneCreateAccount() === false) 
        {
            $this->objFormCreateAccount = null;
            $this->setMessageError(transw('logincontroller_createaccount_errormessage_creatingaccountdisabled', 'Regretfully it is not possible to create an account')); 
            return false;
        }

        $this->modelToFormCreateAccountEnterCredentials();

        
        //form submitted?
        if ($this->objFormCreateAccount->isFormSubmitted())
        {
            /*
            if (!$this->isRecaptchaValid())
            {
                $this->registerAccountCreateAttempt(); //needs to be registered BEFORE the flood detection                
                $this->setMessageError(transw('logincontroller_errormessage_createaccount_recaptchafailed', 'Recaptcha failed sorry'));             
                preventTimingAttack(100,400);
                return false;
            }
            */

            if ($this->objFormCreateAccount->isValid()) 
            {
                if ($this->isValidFormToken($this->objHDFormToken->getContentsSubmitted()->getValueAsString()))
                {

                    $this->registerAccountCreateAttempt();
                    if (!$this->detectFloodAll()) //extra strict flood detection
                    {                   
                        $objUsersTemp = null;
                        $objUsersTemp = $this->getUsers()->getCopy();
                        $sEmailAddress = $this->objEdtEmailAddress->getContentsSubmitted()->getValueAsString();
                        $iCountMatchesEmailAddresses = 0; 

                        if (isValidEmail($sEmailAddress))
                        {                    
                            $objUsersTemp->find(TUsersAbstract::FIELD_EMAILADDRESSFINGERPRINT, $objUsersTemp->generateFingerprintEmail($sEmailAddress));                            
                            $objUsersTemp->loadFromDB();      

                            //from fingerprints: count email address matches in database
                            if ($objUsersTemp->next())
                            {
                                //I want to make 100% sure that the emailaddress matches the encrypted email address, 
                                //different email addresses technically could generate the same fingerprint (although rare)
                                if ($objUsersTemp->isMatchUncryptedValue(TUsersAbstract::FIELD_EMAILADDRESSENCRYPTED,  $sEmailAddress))
                                    $iCountMatchesEmailAddresses++;
                            }

                            //if email already exists in database
                            //send email with question if you are looking to recover password (safer (you dont let users know there is already an email address in your database) and more user-friendlier solution than an error)
                            if ($iCountMatchesEmailAddresses >=1)
                            {
                                $this->objFormCreateAccount = null;
                                return $this->handleCreateAccountEnterCredentialsEmailaddressExists($objUsersTemp->getEmailAddressDecrypted(), $objUsersTemp->getUsername());
                            }
                            else
                            {
                                $objUsersNew = null; 
                                $objUsersNew = $this->getUsers()->getCopy();

                                //is username already taken?
                                if ($objUsersNew->isUsernameTakenDB($this->objEdtUsername->getContentsSubmitted()->getValueAsString()))
                                {
                                    $this->setMessageError(transw('logincontroller_createaccount_errormessage_usernametaken', 'You can\'t choose this username. Choose another one.')); //we are very discrete about the exact natur of the error for security reasons
                                    return false;
                                }

                                $objUsersNew->setUsername($this->objEdtUsername->getContentsSubmitted()->getValueAsString());
                                $objUsersNew->setPasswordDecrypted($this->objEdtPassword->getContentsSubmitted()->getValueAsString());                                
                                $objUsersNew->setEmailAddressDecrypted($this->objEdtEmailAddress->getContentsSubmitted()->getValueAsString());
                                $this->handleCreateAccountEnterCredentialsChild($objUsersNew); //handle child class specifics

                                
                                if ($objUsersNew->saveToDB(true, true)) //save ok
                                {
                                    $this->objFormCreateAccount = null;

                                    
                                    $objTempExpireTokenAndAccount = new TDateTime(time());
                                    $objTempExpireTokenAndAccount->addHour(1);
                                    $sNewEmailTokenDecrypted = password_hash(generatePassword(10, 50), PASSWORD_DEFAULT); //the hash to add extra randomness
                                    $sHashedUsername = password_hash($objUsersNew->getUsername(), PASSWORD_DEFAULT); 
                                    $objUsersNew->setEmailTokenDecrypted($sNewEmailTokenDecrypted);
                                    $objUsersNew->setEmailTokenExpires($objTempExpireTokenAndAccount);
                                    $objUsersNew->setDeleteAfter($objTempExpireTokenAndAccount);//--> schedule account for deletion if user does not activate in time
                                    $objUsersNew->saveToDB();
                                    
                                    //==SEND EMAIL
                                    //setting email variables
                                    $sApplicationName = $this->getApplicationName();
                                    $sURLCreateAccountEmailConfirm = getURLCreateAccountEmailConfirm();
                                    $sURLCreateAccountEmailConfirm = addVariableToURL($sURLCreateAccountEmailConfirm,TLoginControllerAbstract::GETARRAYKEY_USER_RANDOMID, $objUsersNew->getRandomID());
                                    $sURLCreateAccountEmailConfirm = addVariableToURL($sURLCreateAccountEmailConfirm,TLoginControllerAbstract::GETARRAYKEY_USER_EMAILTOKEN, $sNewEmailTokenDecrypted);
                                    $sURLCreateAccountEmailConfirm = addVariableToURL($sURLCreateAccountEmailConfirm,TLoginControllerAbstract::GETARRAYKEY_USER_USERNAME, $sHashedUsername);
                                    $sUserName = $objUsersNew->getUsername();
                                    $sHTMLContentMain = renderTemplate($this->getPathEmailTemplateCreateAccountActivate(), get_defined_vars());
                                    $sHTMLEmailTemplateSkin = renderTemplate($this->getPathEmailSkin(), get_defined_vars()); 
                                
                                    
                                    $objMail = new TMailSend();
                                    $objMail->setTo($sEmailAddress, $sUserName);
                                    $objMail->setFrom($this->getMailbotFromEmailAddress(), $this->getMailbotFromName());
                                    $objMail->setSubject(transw('logincontroller_createaccount_email_subject_activateaccount', 'Activate your new [applicationname] account', 'applicationname', $this->getApplicationName()));
                                    $objMail->setBody($sHTMLEmailTemplateSkin, true);
                                    if ($objMail->send())
                                    {
                                        $this->setMessageNormal(transw('logincontroller_createaccount_message_emailsent', 'An activation email was sent to [emailaddress].<br>Click on the link in the email to activate your account and be able to log in.', 'emailaddress', $this->objEdtEmailAddress->getContentsSubmitted()->getValueAsString()));
                                        $bResult = true;//we want to let the user to know that everything is ok
                                    }
                                    else
                                    {
                                        $this->setMessageError(transw('logincontroller_createaccount_message_emailerror', 'An error has occured sending your email.'));
                                        error_log('EMAIL ERROR: '.__CLASS__.' '.$objMail->getErrorMessage());
                                        $bResult = false;//we want to let the user know: error
                                    }                
                                            

                                }
                                else //save failed
                                {
                                    $this->setMessageError(transw('logincontroller_errormessage_somethingwrong', 'Oops, something went wrong'));
                                    error_log(__CLASS__.': SAVE of user "'.$this->objEdtUsername->getContentsSubmitted()->getValueAsString().'" FAILED!');
                                    logAccess(__CLASS__.': '.__FUNCTION__.': '.__LINE__, 'account creation failed for user (saveToDB() failed)', $this->objEdtUsername->getContentsSubmitted()->getValueAsString());
                                    return false;
                                }

                                unset($objUsersNew);

                            } //end: count matches db
                            unset($objUsersTemp);
                        }
                        else //email not valid: this reeks of an attack
                        {
                            $this->setMessageError(transw('logincontroller_message_handlecreateaccount_emailaddressnotvalid', 'This is not a valid email address'));
                            return false; 
                        }                
                    }
                    else    //flood detected       
                    {            
                        $this->setMessageError(transw('logincontroller_errormessage_handlecreateaccount_entercredentials_flooddetected', 'Account NOT created. You tried to create too many accounts.'));
                        $this->objFormCreateAccount = null; //prevent attacker creating account
                        return false;
                    }     
                }
                else
                {
                    $this->sMessageError = transw('logincontroller_errormessage_handlecreateaccount_entercredentials_formtokeninvalid', 'The form submission expired or form authentication failed. Most likely the time between page load and form submission was too long.');//I want to be discrete about the formtoken for security reasons
                    $this->objFormCreateAccount = null; //prevent attacker from creating account 
                    $bResult = false;                  
                }          
            }
            else
            {
                //showing a form is always quicker than database actions when successfull, 
		        //to keep some mystery about what is going on behind the scenes, slow down the form errors
		        preventTimingAttack(0,200);

                $this->setMessageError(transw('logincontroller_errormessage_handlecreateaccount_correctinputerrors', 'Please correct input errors')); 
                $bResult = false;                   
            }
        }

        return $bResult;
    }  


    /**
     * authenticate user: 
     * see if user is already logged in by looking at
     * cookie and session
     * 
     * return true if authenticated, false if not authenticated
     * 
     * you need to call handleAuthentication() on every page to handle the 
     * authentication and send the user away if failed, this function does
     * ONLY a check
     * 
     * in authenticate() session is loaded from database
     * 
     * @return boolean
     */
    public function authenticate()
    {
        $bAuth = false;
        // logDebug(__CLASS__.': '.__FUNCTION__.': '.__LINE__,'start');


        /* reversed checking: 3 nov 2020. 
        //otherwise it is always possible to login with a cookie. the session is much safer to check first
        //because it is managed on the server, cookies managed on the client-side (where most likely the security-thread is)
        */
        
        //====new method 3 nov 2020: first try session, then cookies
        if (isset($_SESSION[$this->sAKSCATokenID]))
        {
            if (isset($_SESSION[$this->sAKSCAToken]))
            {
                logDebug(__CLASS__.': '.__FUNCTION__.': '.__LINE__,'try session');

                $bAuth = $this->objUsersSessions->loadFromDBByTokensLoginAllowed(
                        $this->objUsers,
                        $this->objLanguage,
                        $_SESSION[$this->sAKSCATokenID],
                        getFingerprintBrowser(),
                        $_SESSION[$this->sAKSCAToken]); //-->loads only sessions, not users
                
                if (!$bAuth)
                    logDebug(__CLASS__.': '.__FUNCTION__.': '.__LINE__,'session auth failed');                        
            }  
            else
            {
                logDebug(__CLASS__.': '.__FUNCTION__.': '.__LINE__,'isset($_SESSION[$this->sAKSCAToken2]) == false: '.$this->sAKSCAToken);
            }                                                
           
        }
        else
        {
            logDebug(__CLASS__.': '.__FUNCTION__.': '.__LINE__,'isset($_SESSION[$this->sAKSCATokenID]) == false: '. $this->sAKSCATokenID);
        }                     
        
        //if session authentication failed, try cookie 
        if (!$bAuth)//session failed?
        {
            if ($this->bUseKeepLoggedIn) //are we allowed to use the cookie at all?
            {
                if (isset($_COOKIE[$this->sAKSCATokenID]))
                {
                    if (isset($_COOKIE[$this->sAKSCAToken]))
                    {
                        logDebug(__CLASS__.': '.__FUNCTION__.': '.__LINE__,'try cookies, '.$_COOKIE[$this->sAKSCAToken]);
                        $bAuth = $this->objUsersSessions->loadFromDBByTokensLoginAllowed(
                                $this->objUsers,
                                $this->objLanguage,
                                $_COOKIE[$this->sAKSCATokenID], 
                                getFingerprintBrowser(),
                                $_COOKIE[$this->sAKSCAToken]); //-->loads only sessions, not users
                    }  

                    if (!$bAuth)
                        logDebug(__CLASS__.': '.__FUNCTION__.': '.__LINE__,'cookie auth failed');                        

                }
                else
                {
                    logDebug(__CLASS__.': '.__FUNCTION__.': '.__LINE__,'isset($_COOKIE[$this->sAKSCATokenID]) == false');
                }


                //session could be timed out when logged-in with cookie, then we need to reload the permissions from database
                $this->populatePermissionsSessionArray(false);    
            }       
        }
        else
        {
            // logDebug(__CLASS__.': '.__FUNCTION__.': '.__LINE__,'$bAuth = true (session)');
        }        

        //need to update permissions NOW??
        if ($bAuth)
        {
            if ($this->objUsers->count() > 0)
            {  
                if ($this->objUsers->getUpdatePermissions())
                {
                    $this->populatePermissionsSessionArray();
    
                    //write to db that we updated the permissions
                    if ($this->objUsers->getUpdatePermissions())
                    {
                        $objTempUser = $this->objUsers->getCopy();
                        $objTempUser->findID($this->objUsers->getID()) ;
                        $objTempUser->loadFromDB();
                        $objTempUser->setUpdatePermissions(false);
                        $objTempUser->saveToDB();
                    }   
    
                }          

                //we log every page a user follows in the access logs. If we ever need to figure out the steps of the user, we can do that this way
                //we log this here, because we have the data about the validated user AND the page information
                logAccess(__CLASS__.': '.__FUNCTION__.': '.__LINE__,'Loaded page: "'.getURLThisScript().'"', $this->objUsers->getUserName());
            }            
        }
        
        
        $this->setIsLoggedIn($bAuth);

             

        return $bAuth; 
    }
    
    /**
     * register session or Cookie when login succesful
     */
    protected function registerSessionOrCookie()
    {
        session_regenerate_id(true); //make a new session id (and keep the current session) to prevent someone stealing your session id and delete the old session file on server
        
        $sEncryptedToken2 = '';
        $sEncryptedToken2 = password_hash($this->objUsersSessions->getLoginToken2WithHashSeed(), PASSWORD_DEFAULT);
        
        $bUseCookie = false;        
        if ($this->bUseKeepLoggedIn) //keep-logged-in is enabled, then we may have a chance to use the cookie, otherwise it's always session
        {
            $bUseCookie = $this->objChkKeepMeLoggedIn->getContentsSubmitted()->getValueAsBool(); //getContentsSubmitted() == null if  $this->bUseKeepLoggedIn == false
        }
        
        // logDebug(__CLASS__.': '.__FUNCTION__.': '.__LINE__,'use cookie')        ;
        //use cookie
        if ($bUseCookie)
        {            
            if (!setcookie($this->sAKSCATokenID, $this->objUsersSessions->getRandomID(), time() + (DAY_IN_SECS * GLOBAL_COOKIE_EXPIREDAYS), '/', GLOBAL_PATH_DOMAIN, GLOBAL_ISHTTPS, true)) // 86400 = 1 day
                $_SESSION[$this->sAKSCATokenID] = $this->objUsersSessions->getRandomID(); //default to session if failed
            if (!setcookie($this->sAKSCAToken, $sEncryptedToken2, time() + (DAY_IN_SECS * GLOBAL_COOKIE_EXPIREDAYS), '/', GLOBAL_PATH_DOMAIN, GLOBAL_ISHTTPS, true)) // 86400 = 1 day
                $_SESSION[$this->sAKSCAToken] = $sEncryptedToken2; //default to session if failed
            
            //generate bogus tokens
            $sTokenName = '';
            $sTokenValue = '';
            for ($iCounter = 1; $iCounter <= TLoginControllerAbstract::BOGUSLOGINTOKENSGENERATED; $iCounter++)
            {
                $sTokenName = $this->sControllerID.TLoginControllerAbstract::LOGINTOKENPREFIX.$iCounter;
                
                if (($sTokenName != $this->sAKSCATokenID) && ($sTokenName != $this->sAKSCAToken))
                {
                    $sTokenValue = generatePassword(10,100);
                    if (!setcookie($sTokenName, $sTokenValue, time() + (DAY_IN_SECS * GLOBAL_COOKIE_EXPIREDAYS), '/', GLOBAL_PATH_DOMAIN, GLOBAL_ISHTTPS, true)) // 86400 = 1 day
                        $_SESSION[$sTokenName] = $sTokenValue; //default to session if failed                    
                }
                
            }
        }
        else //use session
        {
            $_SESSION[$this->sAKSCATokenID] = $this->objUsersSessions->getRandomID();
            $_SESSION[$this->sAKSCAToken] = $sEncryptedToken2;
            
            //generate bogus tokens
            $sTokenName = '';
            $sTokenValue = '';
            for ($iCounter = 1; $iCounter <= TLoginControllerAbstract::BOGUSLOGINTOKENSGENERATED; $iCounter++)
            {
                $sTokenName = $this->sControllerID.TLoginControllerAbstract::LOGINTOKENPREFIX.$iCounter;
                
                if (($sTokenName != $this->sAKSCATokenID) && ($sTokenName != $this->sAKSCAToken))
                {
                    $sTokenValue = generatePassword(10,100);
                    $_SESSION[$sTokenName] = $sTokenValue; 
                }
                
            }            
        }
    }
    
    /**
     * register a FAILED login attempt
     * 
     */
    private function registerFailedLoginAttempt()
    {        
        //in session:
        if (isset($_SESSION[$this->sAKFloodDetectionFailedLoginAttempts]))  
        {      
            $_SESSION[$this->sAKFloodDetectionFailedLoginAttempts][] = time();
        }
        else
            $_SESSION[$this->sAKFloodDetectionFailedLoginAttempts] = array(time());


        //in database:
        logAccess(__CLASS__.': '.__FUNCTION__.': '.__LINE__,': failed login attempt with username: '. $this->objEdtUsername->getContentsSubmitted()->getValueAsString());
        $this->objUsersFloodDetectModel->clear();
        $this->objUsersFloodDetectModel->newRecord();
        // $this->objUsersFloodDetectModel->setUsername($this->objEdtUsername->getContentsSubmitted()->getValueAsString());
        $this->objUsersFloodDetectModel->setUsernameHashedUncrypted($this->objEdtUsername->getContentsSubmitted()->getValueAsString());
        $this->objUsersFloodDetectModel->setIP(getIPAddress());
        $this->objUsersFloodDetectModel->setDateAttempt(new TDateTime(time()));        
        $this->objUsersFloodDetectModel->setIsFailedLoginAttempt(true);        
        $this->objUsersFloodDetectModel->setFingerprintBrowser(getFingerprintBrowser(false));        
        if ($this->objUsersFloodDetectModel->saveToDB())
            error_log (__CLASS__.': '.__FUNCTION__.': '.__LINE__.': objUsersFloodDetectModel->saveToDB() register failed-login-attempt failed');
    }

    /**
     * register a SUCCESSFULL login attempt
     * 
     */
    private function registerSuccessfulLoginAttempt()
    {
        //in session:
        if (isset($_SESSION[$this->sAKFloodDetectionSuccessfulLoginAttempts]))  
        {      
            $_SESSION[$this->sAKFloodDetectionSuccessfulLoginAttempts][] = time();
        }
        else
            $_SESSION[$this->sAKFloodDetectionSuccessfulLoginAttempts] = array(time());



        //====in database: register new succesful attempt
        $this->objUsersFloodDetectModel->clear();
        $this->objUsersFloodDetectModel->newRecord();
        $this->objUsersFloodDetectModel->setUsernameHashedUncrypted(TUsersFloodDetectAbstract::encryptUsername($this->objEdtUsername->getContentsSubmitted()->getValueAsString()));
        $this->objUsersFloodDetectModel->setIP(getIPAddress());
        $this->objUsersFloodDetectModel->setDateAttempt(new TDateTime(time()));        
        $this->objUsersFloodDetectModel->setIsSucceededLoginAttempt(true);        
        $this->objUsersFloodDetectModel->setFingerprintBrowser(getFingerprintBrowser(false));        
        if ($this->objUsersFloodDetectModel->saveToDB())
            error_log (__CLASS__.': '.__FUNCTION__.': '.__LINE__.': objUsersFloodDetectModel->saveToDB() register succesful-login-attempt failed');
    }    
    
    /**
     * register a password reset
     * 
     */
    private function registerPasswordReset()
    {
        //in session:
        if (isset($_SESSION[$this->sAKFloodDetectionPasswordResetAttempts]))  
        {      
            $_SESSION[$this->sAKFloodDetectionPasswordResetAttempts][] = time();
        }
        else
            $_SESSION[$this->sAKFloodDetectionPasswordResetAttempts] = array(time());


        //in database:
        $this->objUsersFloodDetectModel->clear();
        $this->objUsersFloodDetectModel->newRecord();
        if ($this->objEdtEmailAddress) //this can be null when clicked on a link in the email
            $this->objUsersFloodDetectModel->setEmailAddressUncrypted($this->objEdtEmailAddress->getContentsSubmitted()->getValueAsString());
        $this->objUsersFloodDetectModel->setIP(getIPAddress());
        $this->objUsersFloodDetectModel->setDateAttempt(new TDateTime(time()));        
        $this->objUsersFloodDetectModel->setIsPasswordReset(true);        
        $this->objUsersFloodDetectModel->setFingerprintBrowser(getFingerprintBrowser(false));        
        if ($this->objUsersFloodDetectModel->saveToDB())
            error_log (__CLASS__.': '.__FUNCTION__.': '.__LINE__.': objUsersFloodDetectModel->saveToDB() register password reset failed');
    }


    /**
     * register an account creation
     * 
     */
    private function registerAccountCreateAttempt()
    {
        //in session:
        if (isset($_SESSION[$this->sAKFloodDetectionCreateAccountAttempts]))  
        {      
            $_SESSION[$this->sAKFloodDetectionCreateAccountAttempts][] = time();
        }
        else
            $_SESSION[$this->sAKFloodDetectionCreateAccountAttempts] = array(time());


        //in database: 
        $this->objUsersFloodDetectModel->clear();
        $this->objUsersFloodDetectModel->newRecord();
        $this->objUsersFloodDetectModel->setIP(getIPAddress());
        $this->objUsersFloodDetectModel->setDateAttempt(new TDateTime(time()));        
        $this->objUsersFloodDetectModel->setIsCreateAccountAttempt(true);        
        $this->objUsersFloodDetectModel->setFingerprintBrowser(getFingerprintBrowser(false));        
        if ($this->objEdtEmailAddress) //register email address too
        {
            $this->objUsersFloodDetectModel->setEmailAddressUncrypted($this->objEdtEmailAddress->getContentsSubmitted()->getValueAsString());
        }

        if ($this->objUsersFloodDetectModel->saveToDB())
            error_log (__CLASS__.': '.__FUNCTION__.': '.__LINE__.': objUsersFloodDetectModel->saveToDB() register creation attempt failed');
    }

    /**
     * register a new session in database
     */
    protected function registerNewUserSessionInDB()
    {
        //@todo check if session already exists, then only update the field: dateupdated
        $this->objUsersSessions->clear();
        $this->objUsersSessions->setIPAddress(getIPAddress());
        $this->objUsersSessions->setUserID($this->objUsers->getID());
        $this->objUsersSessions->generateTokens(false);
        $this->objUsersSessions->setFingerprintBrowser(getFingerprintBrowser());
        $this->objUsersSessions->setSessionStarted(new TDateTime(time()));
        $this->objUsersSessions->setSessionUpdated(new TDateTime(time()));
        $this->objUsersSessions->setOperatingSystem(getBrowserOS());
        $this->objUsersSessions->setBrowser(getBrowserName());

        return $this->objUsersSessions->saveToDB();
        
    }

    /**
     * do necessary things to log user in
     *
     */    
    private function handleLogIn()
    {
        // logDebug(__CLASS__.': '.__FUNCTION__.': '.__LINE__,'started handleLogin()');
        //is user already/still logged in?
        if ($this->authenticate())
        {               
            // logDebug(__CLASS__.': '.__FUNCTION__.': '.__LINE__,'authenticate() done.');
            
            //update session
            $this->objUsersSessions->setSessionUpdated(new TDateTime(time()));
            $this->objUsersSessions->saveToDB();
            
            //does user need to change password?
            if ($this->objUsers->getPasswordExpires()->isInThePast() && (!$this->objUsers->getPasswordExpires()->isZero()))
            {
                // logDebug(__CLASS__.': '.__FUNCTION__.': '.__LINE__,'Location: '.$this->sURLLoginSuccessUserChangePassword);
                header('Location: '.$this->sURLLoginSuccessUserChangePassword);
                die(); //prevent further script execution
            }
            else
            {
                // logDebug(__CLASS__.': '.__FUNCTION__.': '.__LINE__,'Location: '.$this->sURLLoginSuccess);
                header('Location: '.$this->sURLLoginSuccess);
                die(); //prevent further script execution
            }
        }
        else //not logged in, try to log in
        {
            //is form submitted or is it the first view of the page?
            //else it's the first view of the page, do nothing and show the login form
            if ($this->objFormLogin->isFormSubmitted())
            {
                $this->handleLogInUsernamePasswordSubmitted();
            }

            //SIGN IN WITH GOOGLE: callback from google api (sign-in-with-google)?
            if ($this->getUseSigninWithGoogle())
            {
                if (isset($_GET['code'])) //parameter specific to google api
                {
                    $this->handleLogInGoogleSigninCallback();
                }
            }
                        
        }        
    }


    /**
     * when a login is approved, take all the nessesary steps to ACTUALLY login, 
     * like: creating a login session, setting last-time-logged, register login attempt in etc
     */
    private function registerLogin()
    {
        //register last login
        $this->objUsers->setLastLogin(new TDateTime(time()));

        //register session, cookie and success login attempt
        $this->registerNewUserSessionInDB();
        $this->registerSessionOrCookie();
        $this->registerSuccessfulLoginAttempt();

        if($this->objUsers->saveToDB())
        {
            $this->onLoginSuccess();
            $this->populatePermissionsSessionArray();    
            
            if ($this->objUsers->getPasswordExpires()->isInThePast() && (!$this->objUsers->getPasswordExpires()->isZero()))
            {
                // logDebug(__CLASS__.': '.__FUNCTION__.': '.__LINE__,': Location: '.$this->sURLLoginSuccessUserChangePassword);

                header('Location: '.$this->sURLLoginSuccessUserChangePassword);
                die();   
            }
            else
            {
                // logDebug(__CLASS__.': '.__FUNCTION__.': '.__LINE__,'Location: '.$this->sURLLoginSuccess);

                header('Location: '.$this->sURLLoginSuccess);
                die();    
            }
        }
        else
            logError(__CLASS__.': '.__FUNCTION__.': '.__LINE__,'objUsers->saveToDB() failed');
    }


    /**
     * handle login procedure when username and password are submitted on form
     */
    private function handleLogInUsernamePasswordSubmitted()
    {
        logAccess(__CLASS__.': '.__FUNCTION__.': '.__LINE__, 'LoginForm submitted with username "'.$this->objEdtUsername->getContentsSubmitted()->getValueAsString().'" and a password with '.strlen($this->objEdtPassword->getContentsSubmitted()->getValueAsString()).' characters', $this->objEdtUsername->getContentsSubmitted()->getValueAsString());


        //check input errors
        if ($this->objFormLogin->isValid()) 
        {
            //succesful login?
            if ($this->objUsers->loadFromDBByUserLoginAllowed($this->objEdtUsername->getContentsSubmitted()->getValueAsString(), $this->objEdtPassword->getContentsSubmitted()->getValueAsString()))
            {
                logAccess(__CLASS__.': '.__FUNCTION__.': '.__LINE__, 'LoginForm submitted. User ', $this->objEdtUsername->getContentsSubmitted()->getValueAsString().' approved');

                $this->registerLogin();
            }
            else //login failed
            {
                $this->registerFailedLoginAttempt();

                //go to login form
                // logDebug(__CLASS__.': '.__FUNCTION__.': '.__LINE__,'Location: '.$this->sURLLoginForm);

                preventTimingAttack(300,500);
                header('Location: '.addVariableToURL($this->sURLLoginForm, TLoginControllerAbstract::GETARRAYKEYMESSAGEERROR, transw('logincontroller_loginfailed', 'login failed, user credentials are not valid')));
                die();
            }
        }
        else
        {
            logAccess(__CLASS__.': '.__FUNCTION__.': '.__LINE__, 'LoginForm submitted but had input errors', $this->objEdtUsername->getContentsSubmitted()->getValueAsString());                    
            preventTimingAttack(300,500);
            $this->setMessageError(transw('logincontroller_errormessage_handlelogin_correctinputerrors', 'Please correct input errors'));             
        }
    }
    

    

    /**
     * handle the callback from sign-in-with-google
     */
    private function handleLogInGoogleSigninCallback()
    {
        try
        { 
            $arrGoogleToken = $this->objGoogleClient->fetchAccessTokenWithAuthCode($_GET['code']);
            $_SESSION[SESSIONARRAYKEY_GOOGLEAPI_TOKEN] = $arrGoogleToken;  

    
            if (isset($arrGoogleToken['error']))
            {
                logError(__CLASS__.': '.__FUNCTION__.': '.__LINE__, $arrGoogleToken['error_description']);
                return false;
            }
            else
            {
                $this->objGoogleClient->setAccessToken($arrGoogleToken['access_token']);

                $objGoogle_oauth = new \Google_Service_Oauth2($this->objGoogleClient);
                $objGoogle_account_info = $objGoogle_oauth->userinfo->get();

                //does user exist?
                if ($this->objUsers->loadFromDBByGoogleID($objGoogle_account_info->id)) //===> assuming loadFromDBByGoogleID() exists. It doesn't on standard user\
                {
                    //geo-location check
                    //@todo geo location check (via whitelist ip + google location)
                    //registerFailedLoginAttempt

                    if ($this->objUsers->count() == 0) //doesn't exist? create user!
                    {
                        // echo $objGoogle_account_info->id.'<br>';  // 
                        // echo $objGoogle_account_info->email.'<br>';  // This is null if the 'email' scope is not present.
                        // echo $objGoogle_account_info->name. '<br>';
                        // echo $objGoogle_account_info->familyName. '<br>';
                        // echo $objGoogle_account_info->gender. '<br>';
                        // echo $objGoogle_account_info->givenName. '<br>';
                        // echo $objGoogle_account_info->locale. '<br>';
                        // echo $objGoogle_account_info->picture. '<br>';

                        $this->objUsers->newRecord();
                        if (!$this->objUsers->handleLogInGoogleSigninCallbackCreateNewUser($objGoogle_oauth))
                            return false;   //can fail when account creation is now allowed for example                     
                        $this->objUsers->setGoogleID($objGoogle_account_info->id); //===> assuming setGoogleID() exists. It doesn't on standard user\
                        $this->objUsers->setUsername($objGoogle_account_info->email); 
                        $this->objUsers->setEmailAddressDecrypted($objGoogle_account_info->email); 

                        //if (!$this->objUsers->saveToDBAll()) {} //saved in registerLogin()
                    }
                    $this->registerLogin();
                }
                else
                {
                    logError(__CLASS__.': '.__FUNCTION__.': '.__LINE__, 'loading user with google id '.$objGoogle_account_info->id.' failed');
                    return false;
                }
            }

        }
        catch (\Exception $e) 
        {
            logError(__CLASS__.': '.__FUNCTION__.': '.__LINE__, 'Caught exception: ',  $e->getMessage());
            return false;
        } 
    }



    
    /**
     * do nessasary things to log user out
     *
     */
    private function handleLogOut()
    {
        //we don't want to destroy the session because some things are stored in the session like 
        //the flood detect of successful logins

        $this->setIsLoggedIn(false);        
        
        //DELETE LOGIN SESSION FROM DATABASE
        //we still need to authenticate, because then the user is loaded from db, 
        //otherwise we don't know which session to remove from db
        //we could delete a sessions based on id, but that would make is possible
        //to stage a DOS attack by filling out ids of other sessions in the
        //cookie, we don't want that        
        if ($this->authenticate()) 
        {

            // if(!$this->objUsersSessions->deleteFromDB_OLD($this->objUsersSessions->getRandomID(), TUsersSessionsAbstract::FIELD_RANDOMID))
            //     error_log(__CLASS__.': '.__FUNCTION__.': '.__LINE__.': deletefromdb failed');
            $iUID = 0;
            $iUID = $this->objUsersSessions->getRandomID();
            $this->objUsersSessions->clear();
            $this->objUsersSessions->find(TUsersSessionsAbstract::FIELD_RANDOMID, $iUID);
            if (!$this->objUsersSessions->deleteFromDB(true))
                error_log(__CLASS__.': '.__FUNCTION__.': '.__LINE__.': deletefromdb failed');            
        }
        else
                error_log(__CLASS__.': '.__FUNCTION__.': '.__LINE__.': authentication failed');


        //====in database: delete old failed login attempts        
        //based on ip address
        $this->objUsersFloodDetectModel->clear();
        $this->objUsersFloodDetectModel->find(TUsersFloodDetectAbstract::FIELD_IPADDRESS, getIPAddress());
        $this->objUsersFloodDetectModel->find(TUsersFloodDetectAbstract::FIELD_ISFAILEDLOGINATTEMPT, true);
        $this->objUsersFloodDetectModel->deleteFromDB(true);
        //based on username
        $this->objUsersFloodDetectModel->clear();
        // $this->objUsersFloodDetectModel->find(TUsersFloodDetectAbstract::FIELD_USERNAME, $this->objEdtUsername->getContentsSubmitted()->getValueAsString());
        $this->objUsersFloodDetectModel->find(TUsersFloodDetectAbstract::FIELD_USERNAMEHASHEDENCRYPTED, TUsersFloodDetectAbstract::encryptUsername($this->objEdtUsername->getContentsSubmitted()->getValueAsString()));        
        $this->objUsersFloodDetectModel->find(TUsersFloodDetectAbstract::FIELD_ISFAILEDLOGINATTEMPT, true);
        $this->objUsersFloodDetectModel->deleteFromDB(true);
        
        
        
        //delete all cookie tokens (including bogus tokens)
        if ($this->bUseKeepLoggedIn)
        {
            $sTokenName = '';
            for ($iCounter = 1; $iCounter <= TLoginControllerAbstract::BOGUSLOGINTOKENSGENERATED; $iCounter++)
            {
                $sTokenName = $this->sControllerID.TLoginControllerAbstract::LOGINTOKENPREFIX.$iCounter;

                if (!setcookie($sTokenName, '', time() - 3600, '/', GLOBAL_PATH_DOMAIN, GLOBAL_ISHTTPS, true))
                    error_log('setcookie '.$sTokenName.' failed (delete cookie)');                

            }    
        }
        
        
        //delete all session tokens
        $sTokenName = '';
        for ($iCounter = 1; $iCounter <= TLoginControllerAbstract::BOGUSLOGINTOKENSGENERATED; $iCounter++)
        {
            $sTokenName = $this->sControllerID.TLoginControllerAbstract::LOGINTOKENPREFIX.$iCounter;

            if (isset($_SESSION[$sTokenName]))
                unset($_SESSION[$sTokenName]);                

        }   
        
        //delete failed login attempts from session
        unset($_SESSION[$this->sAKFloodDetectionFailedLoginAttempts]);
        // unset($_SESSION[$this->sAKFloodDetectionSuccessfulLoginAttempts]); --> kind of pointless when we do this, since this is the whole reason why we track this in the first place
        // unset($_SESSION[$this->sAKFloodDetectionPasswordResetAttempts]); --> out of security I won't delete it, it's still weird when a user tries to reset a password too often
        // unset($_SESSION[$this->sAKFloodDetectionCreateAccountAttempts]); --> out of security I won't delete it, it's still weird when a user tries to create new accounts too often
        

        $this->clearFormTokens();


        $sSIDOld = '';
        $sSIDOld = session_id();            
        session_regenerate_id(true); //make a new session id (and keep the current session) to prevent someone stealing your session id and delete the old session file on server
        logAccess(__CLASS__.': '.__FUNCTION__.': '.__LINE__, 'User logout: Changed phpsessionid from: '.$sSIDOld.' ==> '.session_id());
        

        //===SIGN OUT FROM GOOGLE: logout from Google if we are signed-in-via google
        if (isset($_SESSION[SESSIONARRAYKEY_GOOGLEAPI_TOKEN])) //exists when login-via-google is enabled
        {
            if (isset($_SESSION[SESSIONARRAYKEY_GOOGLEAPI_TOKEN]['access_token']))//even if login-via-google is enabled, it might not have been used to log in by the user
            {
                $this->objGoogleClient->setAccessToken($_SESSION[SESSIONARRAYKEY_GOOGLEAPI_TOKEN]['access_token']);
                $this->objGoogleClient->revokeToken();
                unset($_SESSION[SESSIONARRAYKEY_GOOGLEAPI_TOKEN]);
                logAccess(__CLASS__.': '.__FUNCTION__.': '.__LINE__, 'User sign-out-from google');
            }
        }


        $this->sMessageNormal = transw('logincontroller_logoutcompleted', 'log out completed');
//        logDebug(__CLASS__.': '.__FUNCTION__.': '.__LINE__.': Location: '.$this->sURLLoginFailed);
//        header('Location: '.$this->sURLLoginFailed);        --> this class assumes you are currently on the logout page by generating an url that is the logout url (so no need to go there)
        
        $this->onLogout();
    }
    
    /**
     * the logout url is based on loginformurl but with parameters for logout
     * unique identifier
     */
    public function getURLLogOut()
    {
        $sURL = '';
        $sURL = $this->sURLLoginForm;
        $sURL = addVariableToURL($sURL, TLoginControllerAbstract::GETARRAYKEYLOGOUT, TLoginControllerAbstract::GETARRAYKEYLOGOUTVALUE);
        $sURL = addVariableToURL($sURL, TLoginControllerAbstract::GETARRAYKEYCONTROLLERID, md5($this->sControllerID));
        return $sURL;
    }
    
    /**
     * is in the process of loggin out?
     * 
     * it checks for the controllerid to prevent it's logging out the wrong user session
     */
    protected function isLoggingOut()
    {
        //'logout' exists
        if (isset($_GET[TLoginControllerAbstract::GETARRAYKEYLOGOUT]))
        {
            $this->setIsLoggedIn(false);

            //if 'logout' == 1
            if ($_GET[TLoginControllerAbstract::GETARRAYKEYLOGOUT] == TLoginControllerAbstract::GETARRAYKEYLOGOUTVALUE)
            {
                //if controller-id exists
                if (isset($_GET[TLoginControllerAbstract::GETARRAYKEYCONTROLLERID]))
                {
                    //if controller-id is correct
                    if ($_GET[TLoginControllerAbstract::GETARRAYKEYCONTROLLERID] == md5($this->sControllerID))
                        return true;
                }
            }
        }
        
        return false;
    }
    
    /**
     * prevent too many failed attempts
     * this prevents brute force password crack attacks
     * 
     * this function DOES ALL the checks and calls all the detectFlood..() functions
     * 
     * 
     * @return bool true=flood, false=NO flood detected
     */
    public function detectFloodAll()
    {        


        if ($this->detectFloodGeneric())
            return true;

        if ($this->detectFloodFailedLoginAttempts())
            return true;
        
        if ($this->detectFloodSuccessFulLoginAttempts())
            return true;

        if ($this->detectFloodPasswordResetAttempts())
            return true;            

        if ($this->detectFloodCreateAccountAttempts())
            return true;            


        return false;
    }
    

    /**
     * this detects a flood OF ALL ATTEMPTS (successful logins, failed logins, password resets and account creates)
     *      
     * we rather have a Denial Of Service on logging in, than choking the whole system 
     * if you can't detect ip address (because its changing on every reload) 
     * or can't detect session (because its deleted on every reload), 
     * or can't detect fingerprint (because it changed on every reload), 
     * this is the last resort by detecting all attempts regardless of ip-address, fingerprint, or session
     *
     * @return bool true=flood, false=NO flood detected
     */
    protected function detectFloodGeneric()
    {
        $iTSNow = time();
        $objDateAnHourAgo = new TDateTime($iTSNow);
        $objDateYesterdaySameTime = new TDateTime($iTSNow);
        $objDateLastMonthSameTime = new TDateTime($iTSNow);

        $objDateAnHourAgo->subtractHours(1);
        $objDateYesterdaySameTime->subtractDays(TLoginControllerAbstract::FLOODDETECT_COUNTUNIT_PERDAY);
        $objDateLastMonthSameTime->subtractDays(TLoginControllerAbstract::FLOODDETECT_COUNTUNIT_PERMONTH);


         //==== ALL LOGIN ATTEMPTS
            //database: detect flood based per HOUR
            $this->objUsersFloodDetectModel->clear();
            $this->objUsersFloodDetectModel->countResults(TUsersFloodDetectAbstract::FIELD_RANDOMID, 'countattempts');
            $this->objUsersFloodDetectModel->find(TUsersFloodDetectAbstract::FIELD_DATEATTEMPT, $objDateAnHourAgo, COMPARISON_OPERATOR_GREATER_THAN); //wait 1 hour  
            $this->objUsersFloodDetectModel->loadFromDB();
            if ($this->objUsersFloodDetectModel->count() > 0)//is there a result at all?
            {
                if ($this->objUsersFloodDetectModel->getAsInt('countattempts') > $this->getMaxAllowedAttemptsPerHour())
                {
                    error_log (__CLASS__.': '.__FUNCTION__.': '.__LINE__.': database flood detected per hour based on all attempts. From ip:'. getIPAddress());
                    preventTimingAttack(50, 700);
                    return true;
                }
            }


            //database: detect flood based per DAY
            $this->objUsersFloodDetectModel->clear();
            $this->objUsersFloodDetectModel->countResults(TUsersFloodDetectAbstract::FIELD_RANDOMID, 'countattempts');
            $this->objUsersFloodDetectModel->find(TUsersFloodDetectAbstract::FIELD_DATEATTEMPT, $objDateYesterdaySameTime, COMPARISON_OPERATOR_GREATER_THAN); //wait 24 hours   
            $this->objUsersFloodDetectModel->loadFromDB();
            if ($this->objUsersFloodDetectModel->count() > 0)//is there a result at all?
            {                
                if ($this->objUsersFloodDetectModel->getAsInt('countattempts') > $this->getMaxAllowedAttemptsPerDay())
                {
                    error_log (__CLASS__.': '.__FUNCTION__.': '.__LINE__.': database flood detected per day based on all attempts. Last ip:'. getIPAddress());
                    preventTimingAttack(10, 150);

                    $sEmailMessage = '';
                    $sEmailMessage = 'Detected flood on ALL attempts ('.$this->getMaxAllowedAttemptsPerDay().' attempts exceeded).<br>It may be busy, but it could also be an attack.<br>'.$this->getApplicationName().' is not allowing anymore logins today';
                    $this->sendEmailToSystemAdmin('flood detected '.$this->getApplicationName(), $sEmailMessage);  

                    return true;
                }
            }

        return false;
    }

    /**
     * this detects a flood of failed login attempts
     *      
     *
     * @return bool true=flood, false=NO flood detected
     */
    protected function detectFloodFailedLoginAttempts()
    {
        $iTSNow = time();
        $objDateAnHourAgo = new TDateTime($iTSNow);
        $objDateYesterdaySameTime = new TDateTime($iTSNow);
        $iDateYesterdaySameTime = 0; //timestamp
        $objDateLastMonthSameTime = new TDateTime($iTSNow);
        $iDateLastMonthSameTime = 0; //timestamp

        $objDateAnHourAgo->subtractHours(1);
        $objDateYesterdaySameTime->subtractDays(TLoginControllerAbstract::FLOODDETECT_COUNTUNIT_PERDAY);
        $iDateYesterdaySameTime = $objDateYesterdaySameTime->getTimestamp();
        $objDateLastMonthSameTime->subtractDays(TLoginControllerAbstract::FLOODDETECT_COUNTUNIT_PERMONTH);
        $iDateLastMonthSameTime = $objDateLastMonthSameTime->getTimestamp();


        //==== FAILED LOGIN ATTEMPTS

        
            //session: failed logins
            $iCountAttempts = 0;
            if (isset($_SESSION[$this->sAKFloodDetectionFailedLoginAttempts]))
            {
                if (is_array($_SESSION[$this->sAKFloodDetectionFailedLoginAttempts]))
                {
                    foreach ($_SESSION[$this->sAKFloodDetectionFailedLoginAttempts] as $iTSAtt) //iTimestampAttempt
                    {
                        //everything within a day counts as an attempt
                        if ($iDateYesterdaySameTime < $iTSAtt)
                            $iCountAttempts++;
                    }
                }
                if ($iCountAttempts > $this->getMaxAllowedFailedLoginAttemptsPerDay())
                {
                    error_log (__CLASS__.': '.__FUNCTION__.': '.__LINE__.': session flood detected on failed login attempts from ip address: '. getIPAddress());
                    preventTimingAttack(2, 250);
                    return true;
                }            
            }
                    
            //database: detect flood based on ip 
            $this->objUsersFloodDetectModel->clear();
            $this->objUsersFloodDetectModel->countResults(TUsersFloodDetectAbstract::FIELD_IPADDRESS, 'countips');
            $this->objUsersFloodDetectModel->find(TUsersFloodDetectAbstract::FIELD_IPADDRESS, getIPAddress());
            $this->objUsersFloodDetectModel->find(TUsersFloodDetectAbstract::FIELD_DATEATTEMPT, $objDateYesterdaySameTime, COMPARISON_OPERATOR_GREATER_THAN); //wait 24 hours   
            $this->objUsersFloodDetectModel->find(TUsersFloodDetectAbstract::FIELD_ISFAILEDLOGINATTEMPT, true); 
            $this->objUsersFloodDetectModel->loadFromDB();
            if ($this->objUsersFloodDetectModel->count() > 0)//is there a result at all?
            {
                if ($this->objUsersFloodDetectModel->getAsInt('countips') > $this->getMaxAllowedFailedLoginAttemptsPerDay())
                {
                    error_log (__CLASS__.': '.__FUNCTION__.': '.__LINE__.': database flood detected based on IP-addres. From ip:'. getIPAddress());
                    preventTimingAttack(100, 300);
                    return true;
                }
            }
        



            //database: detect flood based on hashed username 
            //a smart attacker changes his IP address, but the username stays the same
            if ($this->objFormLogin) //can be null, for example when recovering password
            {
                if ($this->objFormLogin->isFormSubmitted()) //only can flood detect when the form is submitted, not when the form is shown for the first time (then we don't have a username)
                {
                    $this->objUsersFloodDetectModel->clear();
                    $this->objUsersFloodDetectModel->countResults(TUsersFloodDetectAbstract::FIELD_USERNAMEHASHEDENCRYPTED, 'countusers');
                    $this->objUsersFloodDetectModel->find(TUsersFloodDetectAbstract::FIELD_USERNAMEHASHEDENCRYPTED, TUsersFloodDetectAbstract::encryptUsername($this->objEdtUsername->getContentsSubmitted()->getValueAsString()));
                    $this->objUsersFloodDetectModel->find(TUsersFloodDetectAbstract::FIELD_DATEATTEMPT, $objDateYesterdaySameTime, COMPARISON_OPERATOR_GREATER_THAN); //wait 24 hours
                    $this->objUsersFloodDetectModel->find(TUsersFloodDetectAbstract::FIELD_ISFAILEDLOGINATTEMPT, true);                 
                    $this->objUsersFloodDetectModel->loadFromDB();
                    if ($this->objUsersFloodDetectModel->count() > 0)//is there a result at all?
                    {
                        if ($this->objUsersFloodDetectModel->getAsInt('countusers') > $this->getMaxAllowedFailedLoginAttemptsPerDay())
                        {
                            error_log (__CLASS__.': '.__FUNCTION__.': '.__LINE__.': database flood detected based on username. From ip: '. getIPAddress().' on user:'.$this->objEdtUsername->getContentsSubmitted()->getValueAsString());
                            preventTimingAttack(50, 100);                            
                            return true;
                        }
                    }
                }
            }            

        
            //database: detect flood based on browser-fingerprint
            $this->objUsersFloodDetectModel->clear();
            $this->objUsersFloodDetectModel->countResults(TUsersFloodDetectAbstract::FIELD_IPADDRESS, 'countfingerprints');
            $this->objUsersFloodDetectModel->find(TUsersFloodDetectAbstract::FIELD_FINGERPRINTBROWSER, getFingerprintBrowser(false));
            $this->objUsersFloodDetectModel->find(TUsersFloodDetectAbstract::FIELD_DATEATTEMPT, $objDateYesterdaySameTime, COMPARISON_OPERATOR_GREATER_THAN); //wait 24 hours   
            $this->objUsersFloodDetectModel->find(TUsersFloodDetectAbstract::FIELD_ISFAILEDLOGINATTEMPT, true); 
            $this->objUsersFloodDetectModel->loadFromDB();
            if ($this->objUsersFloodDetectModel->count() > 0)//is there a result at all?
            {
                if ($this->objUsersFloodDetectModel->getAsInt('countfingerprints') > ($this->getMaxAllowedFailedLoginAttemptsPerDay() * 10)) //since the browser fingerprinter is not super unique we take this very loose by multiplying the amount of attempts by 10
                {
                    error_log (__CLASS__.': '.__FUNCTION__.': '.__LINE__.': database flood detected based on IP-addres. From ip: '. getIPAddress().' on user:'.$this->objEdtUsername->getContentsSubmitted()->getValueAsString());
                    preventTimingAttack(10, 60);
                    return true;
                }
            }   

                   
        return false;    
    }

    /**
     * this detects a flood of successful login attempts
     *      
     *
     * @return bool true=flood, false=NO flood detected
     */
    protected function detectFloodSuccessFulLoginAttempts()
    {
        $iTSNow = time();
        $objDateAnHourAgo = new TDateTime($iTSNow);
        $objDateYesterdaySameTime = new TDateTime($iTSNow);
        $iDateYesterdaySameTime = 0; //timestamp
        $objDateLastMonthSameTime = new TDateTime($iTSNow);
        $iDateLastMonthSameTime = 0; //timestamp

        $objDateAnHourAgo->subtractHours(1);
        $objDateYesterdaySameTime->subtractDays(TLoginControllerAbstract::FLOODDETECT_COUNTUNIT_PERDAY);
        $iDateYesterdaySameTime = $objDateYesterdaySameTime->getTimestamp();
        $objDateLastMonthSameTime->subtractDays(TLoginControllerAbstract::FLOODDETECT_COUNTUNIT_PERMONTH);
        $iDateLastMonthSameTime = $objDateLastMonthSameTime->getTimestamp();

        //==== SUCCEEEDED LOGIN ATTEMPTS

            //session:  successful logins
            $iCountAttempts = 0;
            if (isset($_SESSION[$this->sAKFloodDetectionSuccessfulLoginAttempts]))
            {
                if (is_array($_SESSION[$this->sAKFloodDetectionSuccessfulLoginAttempts]))
                {
                    foreach ($_SESSION[$this->sAKFloodDetectionSuccessfulLoginAttempts] as $iTSAtt) //iTimestampAttempt
                    {
                        //everything within a day counts as an attempt
                        if ($iDateYesterdaySameTime < $iTSAtt)
                            $iCountAttempts++;
                    }
                }
                if ($iCountAttempts > $this->getMaxAllowedSuccessfulLoginAttemptsPerDay())
                {
                    error_log (__CLASS__.': '.__FUNCTION__.': '.__LINE__.': session flood detected on successful login attempts from ip address: '. getIPAddress());
                    preventTimingAttack(0, 600);
                    return true;
                }            
            }

            //database: detect flood based on username
            if ($this->objFormLogin) //can be null on password reset and create account
            {
                if ($this->objEdtUsername) //this could be null 
                {
                    //I deliberately do not do a find() on fingerprint, so the search in the database is broader
                    $this->objUsersFloodDetectModel->clear();
                    $this->objUsersFloodDetectModel->countResults(TUsersFloodDetectAbstract::FIELD_IPADDRESS, 'countlogins');
                    // $this->objUsersFloodDetectModel->find(TUsersFloodDetectAbstract::FIELD_USERNAME, $this->objEdtUsername->getContentsSubmitted()->getValueAsString());
                    $this->objUsersFloodDetectModel->find(TUsersFloodDetectAbstract::FIELD_USERNAMEHASHEDENCRYPTED, TUsersFloodDetectAbstract::encryptUsername($this->objEdtUsername->getContentsSubmitted()->getValueAsString()));
                    $this->objUsersFloodDetectModel->find(TUsersFloodDetectAbstract::FIELD_DATEATTEMPT, $objDateYesterdaySameTime, COMPARISON_OPERATOR_GREATER_THAN); //wait 24 hours                       
                    $this->objUsersFloodDetectModel->find(TUsersFloodDetectAbstract::FIELD_ISSUCCEEDEDLOGINATTEMPT, true); 
                    $this->objUsersFloodDetectModel->loadFromDB();
                    if ($this->objUsersFloodDetectModel->count() > 0)//is there a result at all?
                    {
                        if ($this->objUsersFloodDetectModel->getAsInt('countlogins') > $this->getMaxAllowedSuccessfulLoginAttemptsPerDay()) 
                        {
                            error_log (__CLASS__.': '.__FUNCTION__.': '.__LINE__.': database flood detected based on IP-addres. From ip: '. getIPAddress().' on user:'.$this->objEdtUsername->getContentsSubmitted()->getValueAsString());
                            preventTimingAttack(50, 700);
                            return true;
                        }
                    }                        
                }
            }

        return false;
    }

    /**
     * this detects a flood of password reset attempts
     *      
     *
     * @return bool true=flood, false=NO flood detected
     */
    protected function detectFloodPasswordResetAttempts()
    {
        $iTSNow = time();
        $objDateAnHourAgo = new TDateTime($iTSNow);
        $objDateYesterdaySameTime = new TDateTime($iTSNow);
        $iDateYesterdaySameTime = 0; //timestamp
        $objDateLastMonthSameTime = new TDateTime($iTSNow);
        $iDateLastMonthSameTime = 0; //timestamp

        $objDateAnHourAgo->subtractHours(1);
        $objDateYesterdaySameTime->subtractDays(TLoginControllerAbstract::FLOODDETECT_COUNTUNIT_PERDAY);
        $iDateYesterdaySameTime = $objDateYesterdaySameTime->getTimestamp();
        $objDateLastMonthSameTime->subtractDays(TLoginControllerAbstract::FLOODDETECT_COUNTUNIT_PERMONTH);
        $iDateLastMonthSameTime = $objDateLastMonthSameTime->getTimestamp();


        //==== PASSWORD RESET

            //session: password resets
            $iCountAttempts = 0;
            if (isset($_SESSION[$this->sAKFloodDetectionPasswordResetAttempts]))
            {
                if (is_array($_SESSION[$this->sAKFloodDetectionPasswordResetAttempts]))
                {
                    foreach ($_SESSION[$this->sAKFloodDetectionPasswordResetAttempts] as $iTSAtt) //iTimestampAttempt
                    {
                        //everything within a day counts as an attempt
                        if ($iDateYesterdaySameTime < $iTSAtt)
                            $iCountAttempts++;
                    }
                }
                if ($iCountAttempts > $this->getMaxAllowedPasswordResetsPerDay())
                {
                    error_log (__CLASS__.': '.__FUNCTION__.': '.__LINE__.': session flood detected on password reset attempts from ip address: '. getIPAddress());
                    preventTimingAttack(50, 100);
                    return true;
                }            
            }        

            //database: 
            if (($this->objFormPassworRecover) || isset($_GET[TLoginControllerAbstract::GETARRAYKEY_USER_RANDOMID])) //on form existence of form or when click on link in email            
            {
                //I deliberately do not do a find() on fingerprint, so the search in the database is broader
                $this->objUsersFloodDetectModel->clear();
                $this->objUsersFloodDetectModel->countResults(TUsersFloodDetectAbstract::FIELD_IPADDRESS, 'countresets');
                $this->objUsersFloodDetectModel->find(TUsersFloodDetectAbstract::FIELD_DATEATTEMPT, $objDateYesterdaySameTime, COMPARISON_OPERATOR_GREATER_THAN); //wait 24 hours   
                $this->objUsersFloodDetectModel->find(TUsersFloodDetectAbstract::FIELD_ISPASSWORDRESET, true); 
                $this->objUsersFloodDetectModel->loadFromDB();
                if ($this->objUsersFloodDetectModel->count() > 0)//is there a result at all?
                {
                    if ($this->objUsersFloodDetectModel->getAsInt('countresets') > $this->getMaxAllowedPasswordResetsPerDay()) 
                    {
                        error_log (__CLASS__.': '.__FUNCTION__.': '.__LINE__.': database password reset flood detected based on IP-addres. From ip: '. getIPAddress());
                        preventTimingAttack(0, 90);
                        return true;
                    }
                }                    
            }

            //email address fingerprint: 
            if ($this->objEdtEmailAddress) 
            {
                $this->objUsersFloodDetectModel->clear();
                $this->objUsersFloodDetectModel->countResults(TUsersFloodDetectAbstract::FIELD_FINGERPRINTEMAIL, 'countcreates');
                $this->objUsersFloodDetectModel->find(TUsersFloodDetectAbstract::FIELD_FINGERPRINTEMAIL,  $this->objUsersFloodDetectModel->generateEmailAddressFingerprint($this->objEdtEmailAddress->getContentsSubmitted()->getValueAsString())); 
                // $this->objUsersFloodDetectModel->find(TUsersFloodDetectAbstract::FIELD_ISPASSWORDRESET, true); --> now it also includes create account attempts
                $this->objUsersFloodDetectModel->loadFromDB();
                if ($this->objUsersFloodDetectModel->count() > 0)//is there a result at all?
                {
                    if ($this->objUsersFloodDetectModel->getAsInt('countcreates') > $this->getMaxAllowedPasswordResetsPerDay())
                    {
                        error_log (__CLASS__.': '.__FUNCTION__.': '.__LINE__.': database password reset flood detected based on email address. From email address: '. $this->objEdtEmailAddress->getContentsSubmitted()->getValueAsString());
                        preventTimingAttack(100, 400);
                        return true;
                    }
                }                    
            }            

        return false;
    }    

    /**
     * this detects a flood of creating accounts
     *      
     *
     * @return bool true=flood, false=NO flood detected
     */    
    protected function detectFloodCreateAccountAttempts()
    {
        $iTSNow = time();
        $objDateAnHourAgo = new TDateTime($iTSNow);
        $objDateYesterdaySameTime = new TDateTime($iTSNow);
        $iDateYesterdaySameTime = 0; //timestamp
        $objDateLastMonthSameTime = new TDateTime($iTSNow);
        $iDateLastMonthSameTime = 0; //timestamp

        $objDateAnHourAgo->subtractHours(1);
        $objDateYesterdaySameTime->subtractDays(TLoginControllerAbstract::FLOODDETECT_COUNTUNIT_PERDAY);
        $iDateYesterdaySameTime = $objDateYesterdaySameTime->getTimestamp();
        $objDateLastMonthSameTime->subtractDays(TLoginControllerAbstract::FLOODDETECT_COUNTUNIT_PERMONTH);
        $iDateLastMonthSameTime = $objDateLastMonthSameTime->getTimestamp();

        //==== CREATE ACCOUNT

            //session: account creates
            $iCountAttempts = 0;
            if (isset($_SESSION[$this->sAKFloodDetectionCreateAccountAttempts]))
            {
                if (is_array($_SESSION[$this->sAKFloodDetectionCreateAccountAttempts]))
                {
                    foreach ($_SESSION[$this->sAKFloodDetectionCreateAccountAttempts] as $iTSAtt) //iTimestampAttempt
                    {
                        //everything within a day counts as an attempt
                        if ($iDateLastMonthSameTime < $iTSAtt)
                            $iCountAttempts++;
                    }
                }
                if ($iCountAttempts > $this->getMaxAllowedCreateAccountsPerMonth())
                {
                    error_log (__CLASS__.': '.__FUNCTION__.': '.__LINE__.': session flood detected on account creation attempts from ip address: '. getIPAddress());
                    preventTimingAttack(200, 600);
                    return true;
                }            
            }             
        
            //database: 
            if (($this->objFormCreateAccount) || isset($_GET[TLoginControllerAbstract::GETARRAYKEY_USER_RANDOMID])) //on form existence of form or when click on link in email
            {
                //I deliberately do not do a find() on browser fingerprint, so the search in the database is broader
                $this->objUsersFloodDetectModel->clear();
                $this->objUsersFloodDetectModel->countResults(TUsersFloodDetectAbstract::FIELD_IPADDRESS, 'countcreates');
                $this->objUsersFloodDetectModel->find(TUsersFloodDetectAbstract::FIELD_DATEATTEMPT, $objDateLastMonthSameTime, COMPARISON_OPERATOR_GREATER_THAN); //wait 1 month   
                $this->objUsersFloodDetectModel->find(TUsersFloodDetectAbstract::FIELD_ISCREATEACCOUNTATTEMPT, true); 
                $this->objUsersFloodDetectModel->loadFromDB();
                if ($this->objUsersFloodDetectModel->count() > 0)//is there a result at all?
                {
                    if ($this->objUsersFloodDetectModel->getAsInt('countcreates') > $this->getMaxAllowedCreateAccountsPerMonth())
                    {
                        error_log (__CLASS__.': '.__FUNCTION__.': '.__LINE__.': database create account flood detected based on IP-addres. From ip: '. getIPAddress());
                        preventTimingAttack(90, 500);
                        return true;
                    }
                }                    
            }

            //email address fingerprint: 
            //although 1-emailaddress-at-a-time is standard. users can create and delete accounts multiple times
            //too many creations of an account under the same email address is very suspicious (especially from different IP addresses, so this detection goes beyond IPs)
            if ($this->objEdtEmailAddress) 
            {
                $this->objUsersFloodDetectModel->clear();
                $this->objUsersFloodDetectModel->countResults(TUsersFloodDetectAbstract::FIELD_FINGERPRINTEMAIL, 'countcreates');
                $this->objUsersFloodDetectModel->find(TUsersFloodDetectAbstract::FIELD_FINGERPRINTEMAIL,  $this->objUsersFloodDetectModel->generateEmailAddressFingerprint($this->objEdtEmailAddress->getContentsSubmitted()->getValueAsString())); 
                // $this->objUsersFloodDetectModel->find(TUsersFloodDetectAbstract::FIELD_ISCREATEACCOUNTATTEMPT, true); --> now it also includes password reset attempts
                $this->objUsersFloodDetectModel->loadFromDB();
                if ($this->objUsersFloodDetectModel->count() > 0)//is there a result at all?
                {
                    if ($this->objUsersFloodDetectModel->getAsInt('countcreates') > $this->getMaxAllowedCreateAccountsWithSameEmail())
                    {
                        error_log (__CLASS__.': '.__FUNCTION__.': '.__LINE__.': database create account based on email address. From email address: '. $this->objEdtEmailAddress->getContentsSubmitted()->getValueAsString());
                        preventTimingAttack(100, 400);
                        return true;
                    }
                }                    
            }


        return false;
    }


    /**
     * get google authentication url
     * 
     * 
     * @return string
     */
    public function getURLGoogleAuth()  
    {
        if (!$this->objGoogleClient)
        {
            logError(__CLASS__.': '.__FUNCTION__.': '.__LINE__, 'google client == null. cant return url');
            return;
        }
        
        return $this->objGoogleClient->createAuthUrl();

    }


    
    /****************************************************************************
     *              ABSTRACT METHODS
    ****************************************************************************/
    
    /**
     * unique  class login ID to prevent 2 (or more) login classes on the same site 
     * using the same variables for usernames,passwords etc.
     * 
     * return a constant string that is always the same to identify this class,
     * for example 'cms' or 'webshop'
     * DO NOT GENERATE with uniqid() then this class won't authenticate!!!!!!!!!!!
     * 
     * @return string
     */
    abstract public function getControllerID();
    
    /**
     * what is the url of the loginform?
     * use full urls with https in front (no relative urls)!
     * with relative urls it wil redirect to the relative script which 
     * can be non-existing if not in root directory!
     * 
     * for example for a cms it could be: https://www.mysite.com/cms/index.php
     *      
     * This class will redirect logouts and login-fails to this url.    
     * 
     * DO NOT USE getURLThisScript()! because it depends on the script that 
     * calls this class, this class does header redirects, the script will change
     * at it will call itself indefinitely
     * 
     * @return string
     */
    abstract public function getURLLoginForm();
    
    /**
     * what url do you want to forward if a login is succesful?
     * use full urls with https in front (no relative urls)!
     * with relative urls it wil redirect to the relative script which 
     * can be non-existing if not in root directory!
     * 
     * for example for a cms it could be: https://www.mysite.com/cms/home.php
     *      
     * This class will redirect successful logins to this url.
     * 
     * @return string
     */
    abstract public function getURLLoginSuccess();

    /**
     * what url do you want to forward if a login is succesful?
     * BUT THE USER NEEDS TO CHANGE HIS/HER PASSWORD
     * 
     * use full urls with https in front (no relative urls)!
     * with relative urls it wil redirect to the relative script which 
     * can be non-existing if not in root directory!
     * 
     * for example for a cms it could be: https://www.mysite.com/cms/settings.php
     *      
     * This class will redirect successful logins to this url.
     * 
     * @return string
     */
    abstract public function getURLLoginSuccessUserChangePassword();    
    
    /**
     * what url do you want to forward to to recover a password
     * 
     * for example for a cms it could be: https://www.mysite.com/cms/passwordrecover_enteremail.php
     *      
     * 
     * @return string
     */
    abstract public function getURLPasswordRecoverEnterEmail();    

    /**
     * what url do you want to forward to to recover a enter 
     * 
     * for example for a cms it could be: https://www.mysite.com/cms/passwordrecover_enterpassword.php
     *      
     * 
     * @return string
     */
    abstract public function getURLPasswordRecoverEnterPassword();    
    



    /**
     * the path of the email skin
     *
     * @return string
     */
    abstract public function getPathEmailSkin();
    
    /**
     * get path of the email password recovery email
     *
     * @return string
     */
    abstract public function getPathEmailTemplatePasswordRecover();

    /**
     * get path of the email emailaddress exists template
     *
     * @return string
     */
    abstract public function getPathEmailTemplateCreateAccountEmailExists();

    /**
     * get path of the email temlate to acticate account
     *
     * @return string
     */
    abstract public function getPathEmailTemplateCreateAccountActivate();


    /**
     * get url to create a new account
     * 
     * for example for a cms it could be: https://www.mysite.com/cms/createaccount_entercredentials.php
     *      
     * 
     * @return string
     */
    abstract public function getURLCreateAccountEnterCredentials();    
    
    

    /**
     * get a new object of 
     * @return TUsersAbstract
     */
    abstract public function getNewUsers();

    /**
     * get a new object of 
     * @return TUsersFloodDetectAbstract
     */
    abstract public function getNewUsersFloodDetectModel();
    
    /**
     * get a new object of 
     * @return TUsersSessionsAbstract
     */
    abstract public function getNewUsersSessions();

    /**
     * disable or enable the 'keep me logged in' system via a cookie
     */
    abstract public function getUseKeepLoggedIn();
    
    /**
     * you can define extra functionality when a login is succesful.
     * this function is called right before the header redirect
     */
    abstract protected function onLoginSuccess();
    
    /**
     * you can define extra functionality when a logging out
     */
    abstract protected function onLogout();


    /**
     * populate $_SESSION permission array
     * (user authorisation system)
     * 
     * this function is called right after onLoginSuccess()
     * 
     * @param bool $bForceReload regenerate permissionsarray. on false only load when permissionsarray is empty (default = true)
     * @return bool success??
     */
    abstract protected function populatePermissionsSessionArray($bForceReload = true);
    
    /**
     * if you have additional permissions definied, handle them in this function
     * (user authorisation system)
     * 
     * 
     * @return bool accessgranted
     */
    abstract protected function handleAuthenticationChild();   

    /**
     * if you have additional permissions you want to check
     * (user authorisation system)
     * 
     * 
     * @return bool accessgranted
     */
    // abstract protected function authenticateChild(); //17-11-2022 removed    

    
    /**
     * the mailbot that sends account confirmations and password reset emails
     * has a from emailaddress, for example: system@example.com
     * 
     * @return string email address of the email bot
     */
    abstract protected function getMailbotFromEmailAddress();  

    /**
     * the mailbot that sends account confirmations and password reset emails
     * has a name, for example John Doe in: John Doe <system@example.com>
     * 
     * @return string the name of email address of the email bot
     */
    abstract protected function getMailbotFromName();    
    

    /**
     * generate the form object and all the UI elements to create an account
     * (=username, email address, password + button are already created)
     * 
     */
    abstract public function populateFormCreateAccountEnterCredentialsChild();

    /**
     * specific handling of the child class inside handleCreateAccountEnterCredentials();
     *
     * @param TUsersAbstract $objUsersNew
     * @return void
     */
    abstract public function handleCreateAccountEnterCredentialsChild($objUsersNew);

    /**
     * transfer database elements to form for child class
     * 
     * (the namegiving is because of consistency with other controllers, there is not a lot of 'model' in 'modelToForm')
     */
    abstract protected function modelToFormCreateAccountEnterCredentialsChild();

    /**
     * get name of the application
     * (for example: 'CMS 5')
     * This is used in emails (account activation and password reset)
     * But since this is an abstract controller wich is also used outside the cms, we need to request it
     *
     * @return string
     */
    abstract public function getApplicationName();


    /**
     * is anyone allowed to create an account?
     * for closed systems like a CMS we'd like to switch this off (return false)
     * but for open systems like a webshop we can enable this (return true)
     * 
     * @return bool
     */
    abstract public function getCanAnyoneCreateAccount();


    /**
     * how many failed logins can a user have per day?
     * 
     * @return int
     */
    abstract public function getMaxAllowedFailedLoginAttemptsPerDay();

    /**
     * how many times can a user log-in in a day?
     * how many times can a user log-in in a day?
     * when someone logs in 200 times a day, this smells fishy
     * 
     * @return int
     */
    abstract public function getMaxAllowedSuccessfulLoginAttemptsPerDay();


    /**
     * how many times can a user reset a password in a day?
     * 
     * @return int
     */
    abstract public function getMaxAllowedPasswordResetsPerDay();


    /**
     * how many times can a user create an account PER MONTH?
     * 
     * @return int
     */
    abstract public function getMaxAllowedCreateAccountsPerMonth();

    /**
     * How many times can a user create an account under the same email address.
     * Although 1-at-a-time is ALWAYS standard, this function returns how many creates are allowed
     * in the entire history of the logs in the database.
     * (if you delete the logs once every 6 months, it is keeping track of the last 6 months).
     * 
     * for example: a user can delete an account and create a new one with the same email address.
     * How many times is allowed?
     * Too many times is very suspicious.
     * 
     * @return int
     */
    abstract public function getMaxAllowedCreateAccountsWithSameEmail();    

    /**
     * how many times can the site accept an attempt PER HOUR?
     * this is all attempts: failed logins, successful logins, change password, create accounts
     * We do per day and per hour
     * 
     * this to prevents an overflow of login-type actions to cause a Denial Of Service for logged in users,
     * we rather have a Denial Of Service on logging in than the whole system going down
     * 
     * For a CMS 20 is pretty generous, 
     * but for a site like youtube 20 is pretty conservative
     * 
     * @return int
     */
    abstract public function getMaxAllowedAttemptsPerHour();    

    /**
     * how many times can the site accept an attempt PER DAY?
     * this is ALL attempts for ALL USERS combined: failed logins, successful logins, change password, create accounts
     * 
     * this to prevents an overflow of login-type actions to cause a Denial Of Service for logged in users,
     * we rather have a Denial Of Service on logging in than the whole system going down
     * 
     * For a CMS 100 is pretty generous, 
     * but for a site like youtube 100 is pretty conservative
     * 
     * @return int
     */
    abstract public function getMaxAllowedAttemptsPerDay();    

    /**
     * use google's recaptcha to login?
     * you may want to use this for a cms, but not a webshop
     * 
     * @return bool
     */
    abstract public function getUseRecapthaLogin();  

    /**
     * send an email to system administrator
     * 
     * @return bool
     */
    abstract protected function sendEmailToSystemAdmin($sSubject, $sMessage);
    
    /**
     * use google to sign in?
     * you may want to use this for a cms, but not a webshop
     * 
     * @return bool
     */
    abstract public function getUseSigninWithGoogle();  
}
